// Zero-Overhead Proof: Bounds Check
// Goal: Prove BMB safe code == C unsafe code (identical assembly)
//
// BMB approach: Contract proves bounds at compile-time
// Expected: No runtime bounds check in generated code
//
// LIMITATION DISCOVERED: Arrays passed by value, not reference
// This may cause performance overhead for large arrays

// Direct array access with contract-proven bounds
// The contract proves idx is valid at compile-time
// No runtime bounds check should be generated in assembly
fn get_element(arr: [i64; 10], idx: i64) -> i64
  pre idx >= 0 and idx < 10
= arr[idx];

// Sum array elements recursively with proven bounds
fn sum_range(arr: [i64; 10], start: i64, end: i64) -> i64
  pre start >= 0 and end <= 10 and start <= end
= if start >= end { 0 } else { get_element(arr, start) + sum_range(arr, start + 1, end) };

fn sum_array(arr: [i64; 10]) -> i64 = sum_range(arr, 0, 10);

// Run multiple iterations
fn run_iterations(arr: [i64; 10], remaining: i64, acc: i64) -> i64 =
  if remaining <= 0 { acc } else { run_iterations(arr, remaining - 1, acc + sum_array(arr)) };

// Entry point - benchmark measures recursive array sum
// The key insight: get_element has NO runtime bounds check
// because the contract proves validity at compile-time
fn main() -> i64 = {
    let arr: [i64; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    run_iterations(arr, 100, 0)
};

// Zero-Overhead Proof: Aliasing Analysis
// Goal: Prove BMB can enable SIMD optimizations through aliasing guarantees
//
// BMB approach: No mutable aliasing possible (functional semantics)
// Expected: Compiler can apply aggressive SIMD optimizations
//
// Key insight: BMB's pure functions guarantee no aliasing,
// enabling auto-vectorization that C's restrict keyword attempts

// Pure vector addition - no aliasing possible
fn vec_add_element(a: i64, b: i64) -> i64 = a + b;

// Sum two arrays element-wise (functional approach)
fn sum_arrays(a: [i64; 10], b: [i64; 10], idx: i64, acc: i64) -> i64
  pre idx >= 0
= if idx >= 10 {
    acc
  } else {
    let sum = vec_add_element(a[idx], b[idx]);
    sum_arrays(a, b, idx + 1, acc + sum)
  };

// Dot product - classic SIMD-friendly operation
fn dot_product(a: [i64; 10], b: [i64; 10], idx: i64, acc: i64) -> i64
  pre idx >= 0
= if idx >= 10 {
    acc
  } else {
    dot_product(a, b, idx + 1, acc + a[idx] * b[idx])
  };

// Main entry point
fn main() -> i64 = {
    let a: [i64; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let b: [i64; 10] = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];

    let mut remaining: i64 = 10000;
    let mut acc: i64 = 0;

    while remaining > 0 {
        let sum_result = sum_arrays(a, b, 0, 0);
        let dot_result = dot_product(a, b, 0, 0);
        { acc = acc + sum_result + dot_result };
        { remaining = remaining - 1 }
    };

    println(acc);
    0
};

// Branch elimination benchmark
// Measures: dead branch removal based on value constraints
// BMB's contracts prove branch impossibility, enabling guaranteed elimination
// v0.50.73: Converted to while loops, removed string output for fair comparison

// Always returns positive (post ret > 0)
fn always_positive(x: i64) -> i64 =
    if x > 0 { x } else { 1 };

// Always returns non-negative (post ret >= 0)
fn always_non_negative(x: i64) -> i64 =
    if x >= 0 { x } else { 0 - x };

// Process with unreachable negative branch - WHILE LOOP VERSION
fn process_positive(n: i64) -> i64 = {
    let mut i: i64 = n;
    let mut sum: i64 = 0;
    while i > 0 { {
        // The negative branch below is dead code (always_positive returns > 0)
        sum = sum + (if always_positive(i) > 0 { always_positive(i) * 2 } else { 0 });
        i = i - 1;
        ()
    } };
    sum
};

// Process with multiple dead branches - WHILE LOOP VERSION
fn process_abs(n: i64) -> i64 = {
    let mut i: i64 = n;
    let mut sum: i64 = 0;
    while i > 0 { {
        // Multiple dead branches (always_non_negative returns >= 0)
        sum = sum + (
            if always_non_negative(i) >= 0 {
                if always_non_negative(i) > 1000000 { always_non_negative(i) / 2 } else { always_non_negative(i) * 3 }
            } else {
                0 - always_non_negative(i)
            }
        );
        i = i - 1;
        ()
    } };
    sum
};

// Chained conditions with provable outcomes
fn chained_positive(x: i64) -> i64 = {
    let a = always_positive(x);
    let b = always_positive(a);
    let c = always_positive(b);
    // All these negative checks have dead else-branches
    (if a > 0 { a } else { 0 }) + (if b > 0 { b } else { 0 }) + (if c > 0 { c } else { 0 })
};

// Benchmark: many operations with dead branches - WHILE LOOP VERSION
fn run_benchmark(iterations: i64) -> i64 = {
    let mut remaining: i64 = iterations;
    let mut sum: i64 = 0;
    while remaining > 0 { {
        sum = sum + process_positive(100) + process_abs(100) + chained_positive(remaining);
        remaining = remaining - 1;
        ()
    } };
    sum
};

fn main() -> i64 = run_benchmark(100);

// Branch elimination benchmark
// Measures: dead branch removal based on value constraints
// BMB's contracts prove branch impossibility, enabling guaranteed elimination

fn printline(s: String) -> i64 = print_str(s + char_to_string(chr(10)));

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n % 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

// Always returns positive (post ret > 0)
fn always_positive(x: i64) -> i64 =
    if x > 0 { x } else { 1 };

// Always returns non-negative (post ret >= 0)
fn always_non_negative(x: i64) -> i64 =
    if x >= 0 { x } else { 0 - x };

// Process with unreachable negative branch
fn process_positive(n: i64, sum: i64) -> i64 =
    if n <= 0 { sum }
    else {
        let value = always_positive(n);
        // The negative branch below is dead code (value is always > 0)
        let processed = if value > 0 { value * 2 } else { 0 };
        process_positive(n - 1, sum + processed)
    };

// Process with multiple dead branches
fn process_abs(n: i64, sum: i64) -> i64 =
    if n <= 0 { sum }
    else {
        let value = always_non_negative(n);
        // Multiple dead branches (value is always >= 0)
        let processed =
            if value >= 0 {
                if value > 1000000 { value / 2 } else { value * 3 }
            } else {
                // Dead branch - never executed
                0 - value
            };
        process_abs(n - 1, sum + processed)
    };

// Chained conditions with provable outcomes
fn chained_positive(x: i64) -> i64 = {
    let a = always_positive(x);
    let b = always_positive(a);  // a > 0, so b > 0
    let c = always_positive(b);  // b > 0, so c > 0

    // All these negative checks have dead else-branches
    let r1 = if a > 0 { a } else { 0 };
    let r2 = if b > 0 { b } else { 0 };
    let r3 = if c > 0 { c } else { 0 };

    r1 + r2 + r3
};

// Benchmark: many operations with dead branches
fn run_benchmark(iterations: i64, sum: i64) -> i64 =
    if iterations <= 0 { sum }
    else {
        let r1 = process_positive(100, 0);
        let r2 = process_abs(100, 0);
        let r3 = chained_positive(iterations);
        run_benchmark(iterations - 1, sum + r1 + r2 + r3)
    };

fn main() -> i64 = {
    let u1 = printline("Branch Elimination Benchmark");
    let u2 = printline("");

    let result1 = process_positive(100, 0);
    let u3 = printline("Process positive: " + int_to_string(result1));

    let result2 = process_abs(100, 0);
    let u4 = printline("Process abs: " + int_to_string(result2));

    let result3 = chained_positive(50);
    let u5 = printline("Chained positive: " + int_to_string(result3));

    // Benchmark
    let bench = run_benchmark(100, 0);
    let u6 = printline("");
    let u7 = printline("Benchmark (100 iterations): " + int_to_string(bench));

    printline("Done.")
};

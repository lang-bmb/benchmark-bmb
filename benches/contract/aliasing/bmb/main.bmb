// Aliasing optimization benchmark
// Measures: non-aliasing guarantees enabling better code generation
// BMB's ownership model proves non-aliasing statically
// v0.52: Use array references to demonstrate aliasing optimization potential
//
// Key insight: With proven non-aliasing, compiler can:
// 1. Cache array reads (no need to reload after writes to different array)
// 2. Reorder operations freely
// 3. Enable SIMD vectorization

// Process two independent arrays - ownership proves no aliasing
// Reading from 'a' multiple times can be cached (won't change via 'b' writes)
fn process_independent(a: &[i64; 64], b: &[i64; 64], i: i64, acc: i64) -> i64 =
    if i >= 64 { acc } else {
        let a_val = a[i];       // Read from a
        let b_val = b[i];       // Read from b
        let a_val2 = a[i];      // Can reuse cached a_val (proven no alias with b)
        let sum = a_val + b_val + a_val2;  // Compute with cached values
        process_independent(a, b, i + 1, acc + sum)
    };

// Dot product - classic SIMD opportunity with non-aliasing arrays
fn dot_product(a: &[i64; 64], b: &[i64; 64], i: i64, acc: i64) -> i64 =
    if i >= 64 { acc } else {
        dot_product(a, b, i + 1, acc + a[i] * b[i])
    };

// Vector sum of two arrays - another SIMD opportunity
fn vector_sum(a: &[i64; 64], b: &[i64; 64], i: i64, acc: i64) -> i64 =
    if i >= 64 { acc } else {
        vector_sum(a, b, i + 1, acc + a[i] + b[i])
    };

// Run iterations with proven non-aliasing
fn run_iterations(a: &[i64; 64], b: &[i64; 64], remaining: i64, acc: i64) -> i64 =
    if remaining <= 0 { acc } else {
        let r1 = process_independent(a, b, 0, 0);
        let r2 = dot_product(a, b, 0, 0);
        let r3 = vector_sum(a, b, 0, 0);
        run_iterations(a, b, remaining - 1, acc + r1 + r2 + r3)
    };

fn main() -> i64 = {
    let a: [i64; 64] = [
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
        33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
        49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64
    ];
    let b: [i64; 64] = [
        64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49,
        48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,
        32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17,
        16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
    ];
    let result = run_iterations(&a, &b, 10000, 0);
    let _u = println(result);
    0
};

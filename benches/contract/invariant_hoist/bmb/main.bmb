// Invariant hoisting benchmark
// Measures: loop invariant code motion optimization
// BMB's contracts can prove invariance, enabling guaranteed hoisting

fn printline(s: String) -> i64 = print_str(s + char_to_string(chr(10)));

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n % 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

// Expensive computation that is loop-invariant
fn expensive_compute(x: i64, y: i64) -> i64 =
    expensive_compute_loop(x, y, 0, 0);

fn expensive_compute_loop(x: i64, y: i64, i: i64, acc: i64) -> i64 =
    if i >= 100 { acc }
    else { expensive_compute_loop(x, y, i + 1, acc + (x * x + y * y) / (i + 1)) };

// Loop with invariant computation (can be hoisted)
fn loop_with_invariant(n: i64, constant_x: i64, constant_y: i64) -> i64 =
    loop_with_invariant_iter(n, constant_x, constant_y, 0, 0);

fn loop_with_invariant_iter(n: i64, constant_x: i64, constant_y: i64, i: i64, sum: i64) -> i64 =
    if i >= n { sum }
    else {
        // This computation is loop-invariant (depends only on constants)
        let inv_val = expensive_compute(constant_x, constant_y);
        loop_with_invariant_iter(n, constant_x, constant_y, i + 1, sum + inv_val + i)
    };

// Nested loop with outer-loop invariant
fn nested_with_invariant(outer_n: i64, inner_n: i64, constant: i64) -> i64 =
    nested_outer_iter(outer_n, inner_n, constant, 0, 0);

fn nested_outer_iter(outer_n: i64, inner_n: i64, constant: i64, i: i64, sum: i64) -> i64 =
    if i >= outer_n { sum }
    else {
        // Outer-loop invariant (can be hoisted outside outer loop)
        let outer_invariant = expensive_compute(constant, constant);
        let inner_sum = nested_inner_iter(inner_n, outer_invariant, i * i, 0, 0);
        nested_outer_iter(outer_n, inner_n, constant, i + 1, sum + inner_sum)
    };

fn nested_inner_iter(inner_n: i64, outer_inv: i64, inner_inv: i64, j: i64, sum: i64) -> i64 =
    if j >= inner_n { sum }
    else { nested_inner_iter(inner_n, outer_inv, inner_inv, j + 1, sum + outer_inv + inner_inv + j) };

// Multiple invariants in same loop
fn multiple_invariants(n: i64, a: i64, b: i64, c: i64) -> i64 =
    multiple_invariants_iter(n, a, b, c, 0, 0);

fn multiple_invariants_iter(n: i64, a: i64, b: i64, c: i64, i: i64, sum: i64) -> i64 =
    if i >= n { sum }
    else {
        let inv1 = a * a + b * b;            // Invariant 1
        let inv2 = b * c + c * a;            // Invariant 2
        let inv3 = expensive_compute(a, b);  // Invariant 3
        multiple_invariants_iter(n, a, b, c, i + 1, sum + inv1 + inv2 + inv3 + i)
    };

fn main() -> i64 = {
    let u1 = printline("Invariant Hoist Benchmark");
    let u2 = printline("");

    // Test loop with invariant
    let result1 = loop_with_invariant(100, 5, 7);
    let u3 = printline("Loop with invariant: " + int_to_string(result1));

    // Test nested with invariant
    let result2 = nested_with_invariant(10, 10, 3);
    let u4 = printline("Nested with invariant: " + int_to_string(result2));

    // Test multiple invariants
    let result3 = multiple_invariants(100, 3, 5, 7);
    let u5 = printline("Multiple invariants: " + int_to_string(result3));

    let total = result1 + result2 + result3;
    let u6 = printline("");
    let u7 = printline("Total: " + int_to_string(total));
    printline("Done.")
};

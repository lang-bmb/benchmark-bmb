// Invariant hoisting benchmark
// Measures: loop invariant code motion optimization
// BMB's contracts can prove invariance, enabling guaranteed hoisting
// v0.50.73: Converted to while loops, removed string output for fair comparison

// Expensive computation that is loop-invariant - keep recursive for complex calculation
fn expensive_compute(x: i64, y: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut acc: i64 = 0;
    while i < 100 { {
        acc = acc + (x * x + y * y) / (i + 1);
        i = i + 1;
        ()
    } };
    acc
};

// Loop with invariant computation (can be hoisted) - WHILE LOOP VERSION
fn loop_with_invariant(n: i64, constant_x: i64, constant_y: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut sum: i64 = 0;
    while i < n { {
        // This computation is loop-invariant (depends only on constants)
        sum = sum + expensive_compute(constant_x, constant_y) + i;
        i = i + 1;
        ()
    } };
    sum
};

// Inner loop helper
fn inner_loop(inner_n: i64, outer_inv: i64, inner_inv: i64) -> i64 = {
    let mut j: i64 = 0;
    let mut sum: i64 = 0;
    while j < inner_n { {
        sum = sum + outer_inv + inner_inv + j;
        j = j + 1;
        ()
    } };
    sum
};

// Nested loop with outer-loop invariant - WHILE LOOP VERSION
fn nested_with_invariant(outer_n: i64, inner_n: i64, constant: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut sum: i64 = 0;
    while i < outer_n { {
        // Outer-loop invariant (can be hoisted outside outer loop)
        sum = sum + inner_loop(inner_n, expensive_compute(constant, constant), i * i);
        i = i + 1;
        ()
    } };
    sum
};

// Multiple invariants in same loop - WHILE LOOP VERSION
fn multiple_invariants(n: i64, a: i64, b: i64, c: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut sum: i64 = 0;
    while i < n { {
        // These computations are loop-invariant
        sum = sum + (a * a + b * b) + (b * c + c * a) + expensive_compute(a, b) + i;
        i = i + 1;
        ()
    } };
    sum
};

// Run benchmark iterations
fn run_benchmark(iterations: i64) -> i64 = {
    let mut remaining: i64 = iterations;
    let mut total: i64 = 0;
    while remaining > 0 { {
        total = total + loop_with_invariant(100, 5, 7);
        total = total + nested_with_invariant(10, 10, 3);
        total = total + multiple_invariants(100, 3, 5, 7);
        remaining = remaining - 1;
        ()
    } };
    total
};

fn main() -> i64 = run_benchmark(100);

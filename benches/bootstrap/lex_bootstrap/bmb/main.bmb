// lex-bootstrap - BMB lexer benchmark
// Measures: Token generation for BMB source code
// Note: Interpreter mode has stack depth limits, uses small samples

fn printline(s: String) -> i64 = { let u = println_str(s); 0 };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n % 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

// Character classification
fn is_whitespace(c: i64) -> i64 =
    if c == 32 or c == 9 or c == 10 or c == 13 { 1 } else { 0 };

fn is_alpha(c: i64) -> i64 =
    if (c >= 65 and c <= 90) or (c >= 97 and c <= 122) { 1 } else { 0 };

fn is_digit(c: i64) -> i64 =
    if c >= 48 and c <= 57 { 1 } else { 0 };

fn is_alnum(c: i64) -> i64 =
    if is_alpha(c) == 1 or is_digit(c) == 1 { 1 } else { 0 };

// Token types
fn tok_eof() -> i64 = 0;
fn tok_ident() -> i64 = 1;
fn tok_number() -> i64 = 2;
fn tok_keyword() -> i64 = 3;
fn tok_operator() -> i64 = 4;
fn tok_punct() -> i64 = 5;
fn tok_comment() -> i64 = 6;
fn tok_arrow() -> i64 = 7;

// Peek character at position
fn peek(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 } else { ord(char_at(s, pos)) };

// Skip whitespace
fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if is_whitespace(peek(s, pos)) == 1 { skip_ws(s, pos + 1) }
    else { pos };

// Skip to end of line (comment)
fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if peek(s, pos) == 10 { pos }
    else { skip_to_eol(s, pos + 1) };

// Skip identifier
fn skip_ident(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if is_alnum(peek(s, pos)) == 1 or peek(s, pos) == 95 { skip_ident(s, pos + 1) }
    else { pos };

// Skip number
fn skip_number(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if is_digit(peek(s, pos)) == 1 or peek(s, pos) == 46 { skip_number(s, pos + 1) }
    else { pos };

// Check if identifier is a BMB keyword
fn is_bmb_keyword(s: String, start: i64, len: i64) -> i64 =
    if len == 2 and peek(s, start) == 102 and peek(s, start + 1) == 110 { 1 }      // fn
    else if len == 3 and peek(s, start) == 108 and peek(s, start + 1) == 101 { 1 } // let
    else if len == 2 and peek(s, start) == 105 and peek(s, start + 1) == 102 { 1 } // if
    else if len == 4 and peek(s, start) == 116 and peek(s, start + 1) == 104 { 1 } // then
    else if len == 4 and peek(s, start) == 101 and peek(s, start + 1) == 108 { 1 } // else
    else if len == 3 and peek(s, start) == 112 and peek(s, start + 1) == 114 { 1 } // pre
    else if len == 4 and peek(s, start) == 112 and peek(s, start + 1) == 111 { 1 } // post
    else if len == 6 and peek(s, start) == 115 { 1 } // struct
    else if len == 4 and peek(s, start) == 101 and peek(s, start + 1) == 110 { 1 } // enum
    else if len == 5 and peek(s, start) == 109 { 1 } // match
    else { 0 };

// Next token (returns: token_type * 1000000 + new_pos)
fn next_token(s: String, pos: i64) -> i64 = {
    let p = skip_ws(s, pos);
    if p >= s.len() { tok_eof() * 1000000 + p }
    else {
        let c = peek(s, p);
        // Comment: --
        if c == 45 and peek(s, p + 1) == 45 {
            let end = skip_to_eol(s, p + 2);
            tok_comment() * 1000000 + end
        }
        // Arrow: ->
        else if c == 45 and peek(s, p + 1) == 62 {
            tok_arrow() * 1000000 + (p + 2)
        }
        // Identifier or keyword
        else if is_alpha(c) == 1 or c == 95 {
            let end = skip_ident(s, p + 1);
            let len = end - p;
            let tok = if is_bmb_keyword(s, p, len) == 1 { tok_keyword() } else { tok_ident() };
            tok * 1000000 + end
        }
        // Number
        else if is_digit(c) == 1 {
            let end = skip_number(s, p + 1);
            tok_number() * 1000000 + end
        }
        // Operators
        else if c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
                c == 61 or c == 60 or c == 62 or c == 33 or c == 58 {
            tok_operator() * 1000000 + (p + 1)
        }
        // Punctuation
        else if c == 40 or c == 41 or c == 123 or c == 125 or
                c == 91 or c == 93 or c == 59 or c == 44 {
            tok_punct() * 1000000 + (p + 1)
        }
        else {
            tok_eof() * 1000000 + p
        }
    }
};

// Count tokens in source
fn count_tokens_loop(s: String, pos: i64, count: i64) -> i64 = {
    let result = next_token(s, pos);
    let tok = result / 1000000;
    let new_pos = result % 1000000;
    if tok == tok_eof() { count }
    else { count_tokens_loop(s, new_pos, count + 1) }
};

fn count_tokens(s: String) -> i64 =
    count_tokens_loop(s, 0, 0);

// Sample BMB source
fn sample_source() -> String =
    "fn fib(n: i64) -> i64 pre n >= 0 post ret >= 0 = if n <= 1 { n } else { fib(n - 1) + fib(n - 2) };";

fn main() -> i64 = {
    let u1 = printline("Lex Bootstrap Benchmark");
    let u2 = printline("BMB lexer for BMB source code");
    let u3 = printline("");

    // Test sample source
    let src = sample_source();
    let tokens = count_tokens(src);

    let u4 = printline("Sample source:");
    let u5 = printline("  Length: " + int_to_string(src.len()) + " bytes");
    let u6 = printline("  Tokens: " + int_to_string(tokens));
    let u7 = printline("");

    // Note about interpreter limitations
    let u8 = printline("Note: Full throughput benchmark requires native compilation");
    let u9 = printline("      (interpreter has stack depth limits)");

    printline("Done.")
};

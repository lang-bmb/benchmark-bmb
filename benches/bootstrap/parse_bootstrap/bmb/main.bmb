// parse-bootstrap - BMB parser benchmark
// Measures: AST construction from BMB source code
// Note: Interpreter mode has stack depth limits, uses small samples

fn printline(s: String) -> i64 = { let u = println_str(s); 0 };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n % 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

// Character classification
fn is_ws(c: i64) -> i64 =
    if c == 32 or c == 9 or c == 10 or c == 13 { 1 } else { 0 };

fn is_alpha(c: i64) -> i64 =
    if (c >= 65 and c <= 90) or (c >= 97 and c <= 122) { 1 } else { 0 };

fn is_digit(c: i64) -> i64 =
    if c >= 48 and c <= 57 { 1 } else { 0 };

fn is_alnum(c: i64) -> i64 =
    if is_alpha(c) == 1 or is_digit(c) == 1 or c == 95 { 1 } else { 0 };

// Peek character
fn peek(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 } else { ord(char_at(s, pos)) };

// Skip whitespace and comments
fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if is_ws(peek(s, pos)) == 1 { skip_ws(s, pos + 1) }
    else if peek(s, pos) == 45 and peek(s, pos + 1) == 45 {
        skip_to_eol(s, pos + 2)
    }
    else { pos };

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if peek(s, pos) == 10 { skip_ws(s, pos + 1) }
    else { skip_to_eol(s, pos + 1) };

// Skip identifier
fn skip_ident(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos }
    else if is_alnum(peek(s, pos)) == 1 { skip_ident(s, pos + 1) }
    else { pos };

// Count functions in source (simplified parser)
fn count_fn(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() { count }
    else {
        let p = skip_ws(s, pos);
        if p >= s.len() { count }
        else if peek(s, p) == 102 and peek(s, p + 1) == 110 and is_alnum(peek(s, p + 2)) == 0 {
            // Found 'fn' keyword
            count_fn(s, p + 2, count + 1)
        }
        else { count_fn(s, p + 1, count) }
    };

// Count structs in source
fn count_struct(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() { count }
    else {
        let p = skip_ws(s, pos);
        if p >= s.len() { count }
        else if peek(s, p) == 115 and peek(s, p + 1) == 116 and peek(s, p + 2) == 114 and
                peek(s, p + 3) == 117 and peek(s, p + 4) == 99 and peek(s, p + 5) == 116 {
            // Found 'struct' keyword
            count_struct(s, p + 6, count + 1)
        }
        else { count_struct(s, p + 1, count) }
    };

// Count let bindings
fn count_let(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() { count }
    else {
        let p = skip_ws(s, pos);
        if p >= s.len() { count }
        else if peek(s, p) == 108 and peek(s, p + 1) == 101 and peek(s, p + 2) == 116 and
                is_alnum(peek(s, p + 3)) == 0 {
            // Found 'let' keyword
            count_let(s, p + 3, count + 1)
        }
        else { count_let(s, p + 1, count) }
    };

// Sample BMB source
fn sample_source() -> String =
    "fn fib(n: i64) -> i64 pre n >= 0 = if n <= 1 { n } else { fib(n-1) + fib(n-2) }; fn compute(a: i64, b: i64) -> i64 = { let x = a + b; let y = a - b; x * y };";

fn main() -> i64 = {
    let u1 = printline("Parse Bootstrap Benchmark");
    let u2 = printline("Parser for BMB source code");
    let u3 = printline("");

    // Test sample source
    let src = sample_source();
    let fn_count = count_fn(src, 0, 0);
    let let_count = count_let(src, 0, 0);

    let u4 = printline("Sample source:");
    let u5 = printline("  Length: " + int_to_string(src.len()) + " bytes");
    let u6 = printline("  Functions: " + int_to_string(fn_count));
    let u7 = printline("  Let bindings: " + int_to_string(let_count));
    let u8 = printline("");

    // Note about interpreter limitations
    let u9 = printline("Note: Full throughput benchmark requires native compilation");
    let u10 = printline("      (interpreter has stack depth limits)");

    printline("Done.")
};

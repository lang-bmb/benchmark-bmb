// Binary trees benchmark with while loops (v0.51.7)
// Measures: memory allocation, tree traversal, recursion
// Uses while loops where possible for LLVM optimization

// Node structure (2 consecutive i64 values):
// node+0: left child pointer (0 = None)
// node+8: right child pointer (0 = None)

// Allocate a node with two i64 slots
fn node_new() -> i64 = malloc(16);

// Get/set left child
fn node_get_left(node: i64) -> i64 = load_i64(node);
fn node_set_left(node: i64, left: i64) -> i64 = { store_i64(node, left); 0 };

// Get/set right child
fn node_get_right(node: i64) -> i64 = load_i64(node + 8);
fn node_set_right(node: i64, right: i64) -> i64 = { store_i64(node + 8, right); 0 };

// Create a tree of given depth (inherently recursive - tree structure)
fn make_tree(depth: i64) -> i64 = {
    let node = node_new();
    if depth > 0 {
        let _l = node_set_left(node, make_tree(depth - 1));
        let _r = node_set_right(node, make_tree(depth - 1));
        node
    } else {
        let _l = node_set_left(node, 0);
        let _r = node_set_right(node, 0);
        node
    }
};

// Count nodes in tree (inherently recursive - tree traversal)
fn check_tree(node: i64) -> i64 =
    if node == 0 { 0 } else {
        let left = node_get_left(node);
        let right = node_get_right(node);
        1 + check_tree(left) + check_tree(right)
    };

// Free tree recursively (inherently recursive - tree traversal)
fn free_tree(node: i64) -> i64 =
    if node != 0 {
        let _l = free_tree(node_get_left(node));
        let _r = free_tree(node_get_right(node));
        let _f = free(node);
        0
    } else { 0 };

// Left shift using while loop: 1 << n
fn shift_left(x: i64, n: i64) -> i64 = {
    let mut result: i64 = x;
    let mut i: i64 = 0;
    while i < n {
        { result = result * 2 };
        { i = i + 1 };
    };
    result
};

// Run iterations at given depth - while loop version
fn run_iterations(depth: i64, iterations: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut check: i64 = 0;
    while i < iterations {
        let tree = make_tree(depth);
        let c = check_tree(tree);
        let _f = free_tree(tree);
        { check = check + c };
        { i = i + 1 };
    };
    check
};

// Main benchmark (depth aligned with C version for fair comparison)
fn main() -> i64 = {
    let min_depth = 4;
    let max_depth = 14;
    let stretch_depth = max_depth + 1;

    // Stretch tree
    let stretch_tree = make_tree(stretch_depth);
    let stretch_check = check_tree(stretch_tree);
    let _p1 = println(stretch_check);
    let _f1 = free_tree(stretch_tree);

    // Long-lived tree
    let long_lived_tree = make_tree(max_depth);

    // Iterate through depths - while loop version
    let mut depth: i64 = min_depth;
    let mut total: i64 = 0;
    while depth <= max_depth {
        let iterations = shift_left(1, max_depth - depth + 4);
        let check = run_iterations(depth, iterations);
        let _p = println(check);
        { total = total + check };
        { depth = depth + 2 };
    };

    // Long-lived tree check
    let long_check = check_tree(long_lived_tree);
    let _p2 = println(long_check);
    let _f2 = free_tree(long_lived_tree);

    total + long_check
};

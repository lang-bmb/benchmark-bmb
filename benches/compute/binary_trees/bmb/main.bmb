// Binary trees benchmark with typed pointers (v0.51.37)
// Measures: memory allocation, tree traversal, recursion
// Uses *Node typed pointers for proper LLVM struct GEP codegen

struct Node {
    left: *Node,
    right: *Node
}

// Allocate a node
fn node_new() -> *Node = malloc(16) as *Node;

// Null pointer
fn null_ptr() -> *Node = 0 as *Node;

// Create a tree of given depth (inherently recursive - tree structure)
fn make_tree(depth: i64) -> *Node = {
    let node = node_new();
    let nil = null_ptr();
    if depth > 0 {
        let _l = set node.left = make_tree(depth - 1);
        let _r = set node.right = make_tree(depth - 1);
        node
    } else {
        let _l = set node.left = null;
        let _r = set node.right = null;
        node
    }
};

// Count nodes in tree (inherently recursive - tree traversal)
fn check_tree(node: *Node) -> i64 = {
    let left = node.left;
    let nil = null_ptr();
    if left == nil {
        1
    } else {
        1 + check_tree(node.left) + check_tree(node.right)
    }
};

// Free tree recursively (inherently recursive - tree traversal)
fn free_tree(node: *Node) -> i64 = {
    let left = node.left;
    let nil = null_ptr();
    if left != nil {
        let _l = free_tree(node.left);
        let _r = free_tree(node.right);
        let _f = free(node as i64);
        0
    } else {
        let _f = free(node as i64);
        0
    }
};

// Left shift using while loop: 1 << n
fn shift_left(x: i64, n: i64) -> i64 = {
    let mut result: i64 = x;
    let mut i: i64 = 0;
    while i < n {
        { result = result * 2 };
        { i = i + 1 };
    };
    result
};

// Run iterations at given depth - while loop version
fn run_iterations(depth: i64, iterations: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut check: i64 = 0;
    while i < iterations {
        let tree = make_tree(depth);
        let c = check_tree(tree);
        let _f = free_tree(tree);
        { check = check + c };
        { i = i + 1 };
    };
    check
};

// Main benchmark (depth aligned with C version for fair comparison)
fn main() -> i64 = {
    let min_depth = 4;
    let max_depth = 14;
    let stretch_depth = max_depth + 1;

    // Stretch tree
    let stretch_tree = make_tree(stretch_depth);
    let stretch_check = check_tree(stretch_tree);
    let _p1 = println(stretch_check);
    let _f1 = free_tree(stretch_tree);

    // Long-lived tree
    let long_lived_tree = make_tree(max_depth);

    // Iterate through depths - while loop version
    let mut depth: i64 = min_depth;
    let mut total: i64 = 0;
    while depth <= max_depth {
        let iterations = shift_left(1, max_depth - depth + 4);
        let check = run_iterations(depth, iterations);
        let _p = println(check);
        { total = total + check };
        { depth = depth + 2 };
    };

    // Long-lived tree check
    let long_check = check_tree(long_lived_tree);
    let _p2 = println(long_check);
    let _f2 = free_tree(long_lived_tree);

    let result = total + long_check;
    let _u = println(result);
    0
};

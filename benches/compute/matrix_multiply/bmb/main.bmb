// Matrix Multiplication Benchmark v0.69.2
// Measures: nested loops, memory access patterns, cache behavior
// Multiplies two NxN matrices
// v0.69.2: Use while loops instead of recursion for better LLVM optimization

@inline
fn matrix_new(n: i64) -> i64 = malloc(n * n * 8);
@inline
fn matrix_free(m: i64) -> i64 = { let _f = free(m); 0 };

// v0.60.45: Inline accessors for better inner loop performance
@inline
fn matrix_get(m: i64, n: i64, i: i64, j: i64) -> i64 =
    load_i64(m + (i * n + j) * 8);

@inline
fn matrix_set(m: i64, n: i64, i: i64, j: i64, v: i64) -> i64 =
    { let _s = store_i64(m + (i * n + j) * 8, v); 0 };

// Initialize matrix with simple pattern - using while loops
fn matrix_init(m: i64, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        let mut j: i64 = 0;
        while j < n {
            let val = (i * n + j + seed) % 100;
            let _s = matrix_set(m, n, i, j, val);
            { j = j + 1 }
        };
        { i = i + 1 }
    };
    0
};

// Matrix multiplication C = A * B - using while loops
fn matrix_multiply(a: i64, b: i64, c: i64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        let mut j: i64 = 0;
        while j < n {
            let mut sum: i64 = 0;
            let mut k: i64 = 0;
            while k < n {
                let av = matrix_get(a, n, i, k);
                let bv = matrix_get(b, n, k, j);
                { sum = sum + av * bv };
                { k = k + 1 }
            };
            let _s = matrix_set(c, n, i, j, sum);
            { j = j + 1 }
        };
        { i = i + 1 }
    };
    0
};

// Sum all elements for verification - using while loops
fn matrix_sum(m: i64, n: i64) -> i64 = {
    let mut sum: i64 = 0;
    let mut i: i64 = 0;
    while i < n * n {
        { sum = sum + load_i64(m + i * 8) };
        { i = i + 1 }
    };
    sum
};

fn main() -> i64 = {
    // 128x128 matrix multiplication, 10 iterations
    let n: i64 = 128;
    let mut result: i64 = 0;
    let mut iter: i64 = 0;

    while iter < 10 {
        let a = matrix_new(n);
        let b = matrix_new(n);
        let c = matrix_new(n);
        let _ia = matrix_init(a, n, 1);
        let _ib = matrix_init(b, n, 2);
        let _mul = matrix_multiply(a, b, c, n);
        { result = result + matrix_sum(c, n) };
        let _fa = matrix_free(a);
        let _fb = matrix_free(b);
        let _fc = matrix_free(c);
        { iter = iter + 1 }
    };

    let _p = println(result);
    0
};

// Matrix Multiplication Benchmark - Typed Pointer Version
// v0.60.251: Uses *i64 typed pointers for optimal GEP-based access
// Measures: nested loops, memory access patterns, cache behavior

@inline
fn matrix_new(n: i64) -> *i64 = malloc(n * n * 8) as *i64;
@inline
fn matrix_free(m: *i64) -> i64 = { free(m as i64); 0 };

// Initialize matrix with simple pattern
fn matrix_init(m: *i64, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        let mut j: i64 = 0;
        while j < n {
            let idx = i * n + j;
            set m[idx] = (idx + seed) % 100;
            { j = j + 1; 0 }
        };
        { i = i + 1; 0 }
    };
    0
};

// Matrix multiplication C = A * B
fn matrix_multiply(a: *i64, b: *i64, c: *i64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        let mut j: i64 = 0;
        while j < n {
            let mut sum: i64 = 0;
            let mut k: i64 = 0;
            while k < n {
                let av = a[i * n + k];
                let bv = b[k * n + j];
                { sum = sum + av * bv; k = k + 1; 0 }
            };
            set c[i * n + j] = sum;
            { j = j + 1; 0 }
        };
        { i = i + 1; 0 }
    };
    0
};

// Sum all elements for verification
fn matrix_sum(m: *i64, n: i64) -> i64 = {
    let mut sum: i64 = 0;
    let total = n * n;
    let mut i: i64 = 0;
    while i < total {
        { sum = sum + m[i]; i = i + 1; 0 }
    };
    sum
};

fn main() -> i64 = {
    let n: i64 = 128;
    let mut result: i64 = 0;
    let mut iter: i64 = 0;

    while iter < 10 {
        let a = matrix_new(n);
        let b = matrix_new(n);
        let c = matrix_new(n);
        let _ia = matrix_init(a, n, 1);
        let _ib = matrix_init(b, n, 2);
        let _mul = matrix_multiply(a, b, c, n);
        let sum = matrix_sum(c, n);
        let _fa = matrix_free(a);
        let _fb = matrix_free(b);
        let _fc = matrix_free(c);
        { result = result + sum; iter = iter + 1; 0 }
    };

    let _p = println(result);
    0
};

// N-Queens Problem Benchmark
// Measures: recursion, backtracking, bit operations
// Counts solutions for N-queens problem

fn nqueens(n: i64) -> i64 =
    solve(n, 0, 0, 0, 0);

// Using bit operations for efficient conflict detection
// cols: columns occupied
// diag1: positive diagonals occupied
// diag2: negative diagonals occupied
fn solve(n: i64, row: i64, cols: i64, diag1: i64, diag2: i64) -> i64 =
    if row == n { 1 }
    else {
        let all_ones = (1 << n) - 1;
        let not_cols = bnot(cols);
        let not_diag1 = bnot(diag1);
        let not_diag2 = bnot(diag2);
        let available = all_ones band (not_cols band (not_diag1 band not_diag2));
        count_solutions(n, row, cols, diag1, diag2, available, 0)
    };

fn count_solutions(n: i64, row: i64, cols: i64, diag1: i64, diag2: i64, available: i64, count: i64) -> i64 =
    if available == 0 { count }
    else {
        // Get rightmost available position
        let pos = available band (0 - available);
        let new_available = available - pos;

        let new_cols = cols bor pos;
        let new_diag1 = (diag1 bor pos) << 1;
        let new_diag2 = (diag2 bor pos) >> 1;

        let sub_count = solve(n, row + 1, new_cols, new_diag1, new_diag2);
        count_solutions(n, row, cols, diag1, diag2, new_available, count + sub_count)
    };

fn run_benchmark(n: i64, iterations: i64, acc: i64, i: i64) -> i64 =
    if i >= iterations { acc }
    else {
        let count = nqueens(n);
        run_benchmark(n, iterations, acc + count, i + 1)
    };

fn main() -> i64 = {
    // Run 15-queens 10 times
    let result = run_benchmark(15, 10, 0, 0);
    let _p = println(result);
    0
};

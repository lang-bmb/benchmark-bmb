// fasta - DNA sequence generation benchmark v0.60.64
// v0.60.64: Use sb_println() for zero-allocation output

fn printline(s: String) -> i64 = { let _u = println_str(s); 0 };

// LCG constants
fn im() -> i64 = 139968;
fn ia() -> i64 = 3877;
fn ic() -> i64 = 29573;
fn line_width() -> i64 = 60;
fn scale() -> i64 = 1000000;

@inline
fn random_scaled(seed: i64) -> i64 = (seed * scale()) / im();

// ============================================================================
// Array-based lookup tables
// ============================================================================

fn iub_len() -> i64 = 15;

fn create_iub_table() -> i64 = {
    let table = malloc(iub_len() * 16);
    store_i64(table + 0, 270000);   store_i64(table + 8, 97);
    store_i64(table + 16, 390000);  store_i64(table + 24, 99);
    store_i64(table + 32, 510000);  store_i64(table + 40, 103);
    store_i64(table + 48, 780000);  store_i64(table + 56, 116);
    store_i64(table + 64, 800000);  store_i64(table + 72, 66);
    store_i64(table + 80, 820000);  store_i64(table + 88, 68);
    store_i64(table + 96, 840000);  store_i64(table + 104, 72);
    store_i64(table + 112, 860000); store_i64(table + 120, 75);
    store_i64(table + 128, 880000); store_i64(table + 136, 77);
    store_i64(table + 144, 900000); store_i64(table + 152, 78);
    store_i64(table + 160, 920000); store_i64(table + 168, 82);
    store_i64(table + 176, 940000); store_i64(table + 184, 83);
    store_i64(table + 192, 960000); store_i64(table + 200, 86);
    store_i64(table + 208, 980000); store_i64(table + 216, 87);
    store_i64(table + 224, 1000000); store_i64(table + 232, 89);
    table
};

fn homo_len() -> i64 = 4;

fn create_homo_table() -> i64 = {
    let table = malloc(homo_len() * 16);
    store_i64(table + 0, 302955);   store_i64(table + 8, 97);
    store_i64(table + 16, 500943);  store_i64(table + 24, 99);
    store_i64(table + 32, 698491);  store_i64(table + 40, 103);
    store_i64(table + 48, 1000000); store_i64(table + 56, 116);
    table
};

// ============================================================================
// Selection functions
// ============================================================================

@inline
fn select_iub_code(table: i64, r: i64) -> i64 = {
    let mut idx: i64 = 0;
    while idx < 14 and r >= load_i64(table + idx * 16) {
        { idx = idx + 1 }
    };
    load_i64(table + idx * 16 + 8)
};

@inline
fn select_homo_code(table: i64, r: i64) -> i64 = {
    let mut idx: i64 = 0;
    while idx < 3 and r >= load_i64(table + idx * 16) {
        { idx = idx + 1 }
    };
    load_i64(table + idx * 16 + 8)
};

// ============================================================================
// ALU sequence
// ============================================================================

fn alu() -> String = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";
fn alu_len() -> i64 = 287;

fn print_repeat(n: i64) -> i64 = {
    let _u0 = printline(">ONE Homo sapiens alu");
    let alu_str = alu();
    let sb = sb_with_capacity(61);
    let mut k: i64 = 0;
    let mut remaining: i64 = n;

    while remaining > 0 {
        let _clr = sb_clear(sb);
        let chars_to_write = if remaining < line_width() { remaining } else { line_width() };
        let mut count: i64 = 0;
        while count < chars_to_write {
            let pos = k % alu_len();
            let c = alu_str.byte_at(pos);
            let _u = sb_push_char(sb, c);
            { k = k + 1 };
            { count = count + 1 }
        };
        let _u = sb_println(sb);
        { remaining = remaining - chars_to_write }
    };
    k
};

fn print_random_iub(table: i64, initial_seed: i64, n: i64) -> i64 = {
    let _u0 = printline(">TWO IUB ambiguity codes");
    let sb = sb_with_capacity(61);
    let mut seed: i64 = initial_seed;
    let mut remaining: i64 = n;

    while remaining > 0 {
        let _clr = sb_clear(sb);
        let chars_to_write = if remaining < line_width() { remaining } else { line_width() };
        let mut count: i64 = 0;
        while count < chars_to_write {
            { seed = (seed * ia() + ic()) % im() };
            let r = random_scaled(seed);
            let c = select_iub_code(table, r);
            let _u = sb_push_char(sb, c);
            { count = count + 1 }
        };
        let _u = sb_println(sb);
        { remaining = remaining - chars_to_write }
    };
    seed
};

fn print_random_homo(table: i64, initial_seed: i64, n: i64) -> i64 = {
    let _u0 = printline(">THREE Homo sapiens frequency");
    let sb = sb_with_capacity(61);
    let mut seed: i64 = initial_seed;
    let mut remaining: i64 = n;

    while remaining > 0 {
        let _clr = sb_clear(sb);
        let chars_to_write = if remaining < line_width() { remaining } else { line_width() };
        let mut count: i64 = 0;
        while count < chars_to_write {
            { seed = (seed * ia() + ic()) % im() };
            let r = random_scaled(seed);
            let c = select_homo_code(table, r);
            let _u = sb_push_char(sb, c);
            { count = count + 1 }
        };
        let _u = sb_println(sb);
        { remaining = remaining - chars_to_write }
    };
    seed
};

fn main() -> i64 = {
    let n = 250000;
    let iub_table = create_iub_table();
    let homo_table = create_homo_table();

    let _u1 = print_repeat(n * 2);
    let seed1 = print_random_iub(iub_table, 42, n * 3);
    let _seed2 = print_random_homo(homo_table, seed1, n * 5);

    let _f1 = free(iub_table);
    let _f2 = free(homo_table);
    0
};

// fasta - DNA sequence generation benchmark
// Benchmarks Game algorithm with LCG random
// Uses fixed-point arithmetic (1000000 scale factor)

// Helper: print string with newline (println takes i64, not String)
fn printline(s: String) -> i64 = { let u = println_str(s); 0 };

// LCG constants
fn im() -> i64 = 139968;
fn ia() -> i64 = 3877;
fn ic() -> i64 = 29573;
fn line_width() -> i64 = 60;

// Fixed-point scale (for probabilities)
fn scale() -> i64 = 1000000;

// Global seed (simulated with recursion)
fn next_seed(seed: i64) -> i64 = (seed * ia() + ic()) % im();

// Random number as fixed-point (0 to scale)
fn random_scaled(seed: i64) -> i64 = (seed * scale()) / im();

// IUB nucleotide cumulative probabilities (scaled)
fn iub_prob(idx: i64) -> i64 =
    if idx == 0 { 270000 }       -- a: 0.27
    else if idx == 1 { 390000 }   -- c: 0.12 (cumulative)
    else if idx == 2 { 510000 }   -- g: 0.12
    else if idx == 3 { 780000 }   -- t: 0.27
    else if idx == 4 { 800000 }   -- B: 0.02
    else if idx == 5 { 820000 }   -- D: 0.02
    else if idx == 6 { 840000 }   -- H: 0.02
    else if idx == 7 { 860000 }   -- K: 0.02
    else if idx == 8 { 880000 }   -- M: 0.02
    else if idx == 9 { 900000 }   -- N: 0.02
    else if idx == 10 { 920000 }  -- R: 0.02
    else if idx == 11 { 940000 }  -- S: 0.02
    else if idx == 12 { 960000 }  -- V: 0.02
    else if idx == 13 { 980000 }  -- W: 0.02
    else { 1000000 };             -- Y: 0.02

fn iub_char(idx: i64) -> String =
    if idx == 0 { "a" }
    else if idx == 1 { "c" }
    else if idx == 2 { "g" }
    else if idx == 3 { "t" }
    else if idx == 4 { "B" }
    else if idx == 5 { "D" }
    else if idx == 6 { "H" }
    else if idx == 7 { "K" }
    else if idx == 8 { "M" }
    else if idx == 9 { "N" }
    else if idx == 10 { "R" }
    else if idx == 11 { "S" }
    else if idx == 12 { "V" }
    else if idx == 13 { "W" }
    else { "Y" };

fn iub_len() -> i64 = 15;

// Homo sapiens cumulative probabilities (scaled)
fn homo_prob(idx: i64) -> i64 =
    if idx == 0 { 302955 }        -- a: 0.3029549426680
    else if idx == 1 { 500943 }   -- c: 0.1979883004921
    else if idx == 2 { 698491 }   -- g: 0.1975473066391
    else { 1000000 };             -- t: 0.3015094502008

fn homo_char(idx: i64) -> String =
    if idx == 0 { "a" }
    else if idx == 1 { "c" }
    else if idx == 2 { "g" }
    else { "t" };

fn homo_len() -> i64 = 4;

// Select nucleotide based on random value
fn select_iub(r: i64, idx: i64) -> String =
    if idx >= iub_len() { iub_char(iub_len() - 1) }
    else if r < iub_prob(idx) { iub_char(idx) }
    else { select_iub(r, idx + 1) };

fn select_homo(r: i64, idx: i64) -> String =
    if idx >= homo_len() { homo_char(homo_len() - 1) }
    else if r < homo_prob(idx) { homo_char(idx) }
    else { select_homo(r, idx + 1) };

// ALU sequence
fn alu() -> String = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

fn alu_len() -> i64 = 287;

// Build repeat line (returns accumulated string and next k position)
fn build_repeat_line(alu_str: String, k: i64, remaining: i64, line: String) -> String =
    if remaining == 0 or line.len() >= line_width() { line }
    else {
        let pos = k % alu_len();
        let c = alu_str.slice(pos, pos + 1);
        build_repeat_line(alu_str, k + 1, remaining - 1, line + c)
    };

// Generate repeat sequence (ALU) - returns k position
fn print_repeat_lines(alu_str: String, k: i64, remaining: i64) -> i64 =
    if remaining <= 0 { k }
    else {
        let line = build_repeat_line(alu_str, k, remaining, "");
        let u = printline(line);
        let chars_printed = line.len();
        print_repeat_lines(alu_str, k + chars_printed, remaining - chars_printed)
    };

fn print_repeat(n: i64) -> i64 = {
    let u0 = printline(">ONE Homo sapiens alu");
    print_repeat_lines(alu(), 0, n)
};

// Build random IUB line (returns seed and line as string encoded pair)
fn build_random_iub_line(seed: i64, remaining: i64, line: String) -> String =
    if remaining == 0 or line.len() >= line_width() {
        -- Encode seed in the result (hacky but works for benchmark)
        line
    }
    else {
        let new_seed = next_seed(seed);
        let r = random_scaled(new_seed);
        let c = select_iub(r, 0);
        build_random_iub_line(new_seed, remaining - 1, line + c)
    };

-- For random sequences, we need to track seed through recursion
-- Simplified version: generate all random numbers at once with iteration count
fn generate_random_iub_iter(seed: i64, remaining: i64, line: String) -> i64 =
    if remaining <= 0 {
        -- Print remaining partial line if any
        let _u = if line.len() > 0 { printline(line) } else { printline("") };
        seed
    }
    else if line.len() >= line_width() {
        let u = printline(line);
        generate_random_iub_iter(seed, remaining, "")
    }
    else {
        let new_seed = next_seed(seed);
        let r = random_scaled(new_seed);
        let c = select_iub(r, 0);
        generate_random_iub_iter(new_seed, remaining - 1, line + c)
    };

fn print_random_iub(seed: i64, n: i64) -> i64 = {
    let u0 = printline(">TWO IUB ambiguity codes");
    let final_seed = generate_random_iub_iter(seed, n, "");
    final_seed
};

-- Random homo sapiens sequence
fn generate_random_homo_iter(seed: i64, remaining: i64, line: String) -> i64 =
    if remaining <= 0 {
        -- Print remaining partial line if any
        let _u = if line.len() > 0 { printline(line) } else { printline("") };
        seed
    }
    else if line.len() >= line_width() {
        let u = printline(line);
        generate_random_homo_iter(seed, remaining, "")
    }
    else {
        let new_seed = next_seed(seed);
        let r = random_scaled(new_seed);
        let c = select_homo(r, 0);
        generate_random_homo_iter(new_seed, remaining - 1, line + c)
    };

fn print_random_homo(seed: i64, n: i64) -> i64 = {
    let u0 = printline(">THREE Homo sapiens frequency");
    generate_random_homo_iter(seed, n, "")
};

fn main() -> i64 = {
    let n = 100;  -- smaller size for interpreter (100 instead of 1000)
    let u1 = print_repeat(n * 2);
    let seed1 = print_random_iub(42, n * 3);
    let seed2 = print_random_homo(seed1, n * 5);
    0
};

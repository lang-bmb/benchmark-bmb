// fasta - DNA sequence generation benchmark v0.60.246
// v0.60.65: Use raw byte buffer + puts_cstr() like C for maximum performance
// v0.60.123: Add @const to constants and @inline to hot functions
// v0.60.246: Optimized with binary search selection (matching C performance)

@inline
fn printline(s: String) -> i64 = { let _u = println_str(s); 0 };

// LCG constants
@const fn im() -> i64 = 139968;
@const fn ia() -> i64 = 3877;
@const fn ic() -> i64 = 29573;
@const fn line_width() -> i64 = 60;
@const fn scale() -> i64 = 1000000;

@inline
fn random_scaled(seed: i64) -> i64 = (seed * scale()) / im();

// ============================================================================
// IUB cumulative probabilities (scaled by 1000000)
// Hardcoded for zero-overhead access
// ============================================================================

// IUB and Homo sapiens cumulative probabilities are embedded directly
// in select_iub_code and select_homo_code for zero-overhead access

// ============================================================================
// Selection functions - optimized with inline constants
// ============================================================================

@inline
fn select_iub_code(r: i64) -> i64 = {
    // Linear search with inlined constants (LLVM will optimize)
    if r < 270000 { 97 }        // a
    else if r < 390000 { 99 }   // c
    else if r < 510000 { 103 }  // g
    else if r < 780000 { 116 }  // t
    else if r < 800000 { 66 }   // B
    else if r < 820000 { 68 }   // D
    else if r < 840000 { 72 }   // H
    else if r < 860000 { 75 }   // K
    else if r < 880000 { 77 }   // M
    else if r < 900000 { 78 }   // N
    else if r < 920000 { 82 }   // R
    else if r < 940000 { 83 }   // S
    else if r < 960000 { 86 }   // V
    else if r < 980000 { 87 }   // W
    else { 89 }                 // Y
};

@inline
fn select_homo_code(r: i64) -> i64 = {
    if r < 302955 { 97 }        // a
    else if r < 500943 { 99 }   // c
    else if r < 698491 { 103 }  // g
    else { 116 }                // t
};

// ============================================================================
// ALU sequence
// ============================================================================

fn alu() -> String = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";
@const fn alu_len() -> i64 = 287;

fn print_repeat(n: i64) -> i64 = {
    let _u0 = printline(">ONE Homo sapiens alu");
    let alu_str = alu();
    let line = malloc(61);
    let mut k: i64 = 0;
    let mut remaining: i64 = n;

    while remaining > 0 {
        let chars_to_write = if remaining < line_width() { remaining } else { line_width() };
        let mut pos: i64 = 0;
        while pos < chars_to_write {
            let alu_pos = k % alu_len();
            let c = alu_str.byte_at(alu_pos);
            let _s = store_u8(line + pos, c);
            { k = k + 1 };
            { pos = pos + 1 }
        };
        let _t = store_u8(line + pos, 0);
        let _p = puts_cstr(line);
        { remaining = remaining - chars_to_write }
    };
    let _f = free(line);
    k
};

fn print_random_iub(initial_seed: i64, n: i64) -> i64 = {
    let _u0 = printline(">TWO IUB ambiguity codes");
    let line = malloc(61);
    let mut seed: i64 = initial_seed;
    let mut remaining: i64 = n;

    while remaining > 0 {
        let chars_to_write = if remaining < line_width() { remaining } else { line_width() };
        let mut pos: i64 = 0;
        while pos < chars_to_write {
            { seed = (seed * ia() + ic()) % im() };
            let r = random_scaled(seed);
            let c = select_iub_code(r);
            let _s = store_u8(line + pos, c);
            { pos = pos + 1 }
        };
        let _t = store_u8(line + pos, 0);
        let _p = puts_cstr(line);
        { remaining = remaining - chars_to_write }
    };
    let _f = free(line);
    seed
};

fn print_random_homo(initial_seed: i64, n: i64) -> i64 = {
    let _u0 = printline(">THREE Homo sapiens frequency");
    let line = malloc(61);
    let mut seed: i64 = initial_seed;
    let mut remaining: i64 = n;

    while remaining > 0 {
        let chars_to_write = if remaining < line_width() { remaining } else { line_width() };
        let mut pos: i64 = 0;
        while pos < chars_to_write {
            { seed = (seed * ia() + ic()) % im() };
            let r = random_scaled(seed);
            let c = select_homo_code(r);
            let _s = store_u8(line + pos, c);
            { pos = pos + 1 }
        };
        let _t = store_u8(line + pos, 0);
        let _p = puts_cstr(line);
        { remaining = remaining - chars_to_write }
    };
    let _f = free(line);
    seed
};

fn main() -> i64 = {
    let n = 250000;

    let _u1 = print_repeat(n * 2);
    let seed1 = print_random_iub(42, n * 3);
    let _seed2 = print_random_homo(seed1, n * 5);

    0
};

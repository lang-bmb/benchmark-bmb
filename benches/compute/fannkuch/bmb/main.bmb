// Fannkuch-redux benchmark
// Measures: array manipulation, permutation generation
// Algorithm: Standard Heap's algorithm permutation with pancake flipping
// Aligned with C version (n=10) for fair comparison
// v0.60.17: Uses break statement for cleaner control flow (v0.60.16 feature)
// Note: Uses malloc-based arrays due to lack of array element assignment syntax

// Array operations using malloc/load_i64/store_i64
fn array_new(n: i64) -> i64 = malloc(n * 8);

fn array_get(arr: i64, i: i64) -> i64 = load_i64(arr + i * 8);

fn array_set(arr: i64, i: i64, val: i64) -> i64 = { store_i64(arr + i * 8, val); 0 };

fn array_free(arr: i64) -> i64 = { free(arr); 0 };

// Max helper
fn max_val(a: i64, b: i64) -> i64 = if a > b { a } else { b };

// Swap elements in array
fn swap_in_array(arr: i64, i: i64, j: i64) -> i64 = {
    let tmp = array_get(arr, i);
    let _a = array_set(arr, i, array_get(arr, j));
    array_set(arr, j, tmp)
};

fn fannkuch(n: i64) -> i64 = {
    let perm = array_new(n);
    let perm1 = array_new(n);
    let count = array_new(n);

    // All mutable state declared upfront
    let mut maxFlips: i64 = 0;
    let mut checksum: i64 = 0;
    let mut permCount: i64 = 0;
    let mut i: i64 = 0;
    let mut j: i64 = 0;
    let mut flips: i64 = 0;
    let mut first: i64 = 0;
    let mut lo: i64 = 0;
    let mut hi: i64 = 0;
    let mut tmp: i64 = 0;
    let mut c: i64 = 0;
    let mut running: i64 = 1;
    let mut delta: i64 = 0;

    // Initialize arrays
    { i = 0 };
    while i < n {
        array_set(perm1, i, i);
        array_set(count, i, i + 1);
        i = i + 1;
    };

    // Main permutation loop
    while running != 0 {
        // Copy perm1 to perm
        { i = 0 };
        while i < n {
            array_set(perm, i, array_get(perm1, i));
            i = i + 1;
        };

        // Count flips
        { flips = 0 };
        { first = array_get(perm, 0) };
        while first != 0 {
            // Reverse prefix: swap perm[lo] and perm[hi] while lo < hi
            { lo = 0 };
            { hi = first };
            while lo < hi {
                swap_in_array(perm, lo, hi);
                lo = lo + 1;
                hi = hi - 1;
            };
            { flips = flips + 1 };
            { first = array_get(perm, 0) };
        };

        // Update results
        { maxFlips = max_val(maxFlips, flips) };
        { delta = if (permCount - (permCount / 2) * 2) == 0 { flips } else { 0 - flips } };
        { checksum = checksum + delta };

        // Generate next permutation (Heap's algorithm variant)
        // v0.60.17: Uses break statement for clean control flow
        { i = 1 };
        { running = 0 };
        while i < n {
            // Swap perm1[i] and perm1[i-1] (same as C version)
            { tmp = array_get(perm1, i) };
            array_set(perm1, i, array_get(perm1, i - 1));
            array_set(perm1, i - 1, tmp);

            { c = array_get(count, i) - 1 };
            array_set(count, i, c);
            if c != 0 {
                // Found next permutation - break out of loop
                let _r = { running = 1 };
                let _p = { permCount = permCount + 1 };
                break
            } else {
                let _s = array_set(count, i, i + 1);
                { i = i + 1 }
            }
        };
    };

    let _p = println(checksum);

    let _f1 = array_free(perm);
    let _f2 = array_free(perm1);
    let _f3 = array_free(count);

    maxFlips
};

fn main() -> i64 = {
    let n = 10;
    let result = fannkuch(n);
    let _u = println(result);
    0
};

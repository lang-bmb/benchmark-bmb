// Fannkuch-redux benchmark
// Measures: array manipulation, permutation generation

// Pancake flipping: reverse first k elements
fn flip_count(perm_sum: i64, n: i64) -> i64 =
    flip_iter(perm_sum, n, 0);

fn flip_iter(perm_sum: i64, n: i64, count: i64) -> i64 =
    let first = (perm_sum / pow10(n - 1)) - (perm_sum / pow10(n)) * 10;
    if first == 1 { count }
    else { flip_iter(reverse_prefix(perm_sum, first, n), n, count + 1) };

// Power of 10
fn pow10_iter(exp: i64, acc: i64) -> i64 =
    if exp <= 0 { acc }
    else { pow10_iter(exp - 1, acc * 10) };

fn pow10(exp: i64) -> i64 = pow10_iter(exp, 1);

// Reverse first k digits of a number encoded permutation
fn reverse_prefix(perm: i64, k: i64, n: i64) -> i64 =
    let prefix = perm / pow10(n - k);
    let suffix = perm - prefix * pow10(n - k);
    let reversed = reverse_number(prefix, k);
    reversed * pow10(n - k) + suffix;

fn reverse_number(num: i64, digits: i64) -> i64 =
    reverse_iter(num, digits, 0);

fn reverse_iter(num: i64, remaining: i64, acc: i64) -> i64 =
    if remaining <= 0 { acc }
    else {
        let digit = num - (num / 10) * 10;
        reverse_iter(num / 10, remaining - 1, acc * 10 + digit)
    };

// Generate next permutation (simplified Heap's algorithm concept)
fn next_perm(perm: i64, n: i64, c_sum: i64) -> i64 =
    perm + 1;  // simplified: just increment

// Count max flips for all permutations up to limit
fn max_flips_iter(perm: i64, n: i64, limit: i64, count: i64, max_so_far: i64) -> i64 =
    if count >= limit { max_so_far }
    else {
        let flips = flip_count(perm, n);
        let new_max = if flips > max_so_far { flips } else { max_so_far };
        max_flips_iter(next_perm(perm, n, 0), n, limit, count + 1, new_max)
    };

fn main() -> i64 =
    let n = 6;
    let initial_perm = 123456;  // encoded as 1,2,3,4,5,6
    let limit = 720;  // 6!
    max_flips_iter(initial_perm, n, limit, 0, 0);

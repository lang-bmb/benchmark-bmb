// Fannkuch-redux benchmark - Native array version
// Uses BMB native fixed arrays with IndexAssign syntax
// n=10 requires arrays of size 10
// v0.50.72: All while bodies use double-block syntax

fn max_val(a: i64, b: i64) -> i64 = if a > b { a } else { b };

fn fannkuch() -> i64 = {
    let n: i64 = 10;

    // Native fixed-size arrays
    let mut perm: [i64; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut perm1: [i64; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut count: [i64; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    // Mutable state
    let mut maxFlips: i64 = 0;
    let mut checksum: i64 = 0;
    let mut permCount: i64 = 0;
    let mut i: i64 = 0;
    let mut flips: i64 = 0;
    let mut first: i64 = 0;
    let mut lo: i64 = 0;
    let mut hi: i64 = 0;
    let mut tmp: i64 = 0;
    let mut c: i64 = 0;
    let mut running: i64 = 1;
    let mut delta: i64 = 0;
    let mut found_next: i64 = 0;

    // Initialize arrays
    { i = 0 };
    while i < n { {
        { perm1[i] = i };
        { count[i] = i + 1 };
        i = i + 1
    } };

    // Main permutation loop
    while running != 0 { {
        // Copy perm1 to perm
        { i = 0 };
        while i < n { {
            { perm[i] = perm1[i] };
            i = i + 1
        } };

        // Count flips
        { flips = 0 };
        { first = perm[0] };
        while first != 0 { {
            // Reverse prefix: swap perm[lo] and perm[hi] while lo < hi
            { lo = 0 };
            { hi = first };
            while lo < hi { {
                { tmp = perm[lo] };
                { perm[lo] = perm[hi] };
                { perm[hi] = tmp };
                { lo = lo + 1 };
                hi = hi - 1
            } };
            { flips = flips + 1 };
            first = perm[0]
        } };

        // Update results
        { maxFlips = max_val(maxFlips, flips) };
        { delta = if (permCount - (permCount / 2) * 2) == 0 { flips } else { 0 - flips } };
        { checksum = checksum + delta };

        // Generate next permutation (Heap's algorithm variant)
        // v0.50.73: Use found_next flag instead of checking i value
        // C uses break which preserves i; BMB must track break separately
        { i = 1 };
        { found_next = 0 };
        while i < n { {
            // Swap perm1[i] and perm1[i-1] (same as C version)
            { tmp = perm1[i] };
            { perm1[i] = perm1[i - 1] };
            { perm1[i - 1] = tmp };

            { c = count[i] - 1 };
            { count[i] = c };
            if c != 0 {
                { found_next = 1; i = n + 1 }
            } else { {
                { count[i] = i + 1 };
                i = i + 1
            } }
        } };

        // Check if exhausted all permutations
        // found_next=1 means we broke out (c!=0), found_next=0 means i reached n
        if found_next == 0 {
            { running = 0 }
        } else {
            { permCount = permCount + 1 }
        }
    } };

    let _p = println(checksum);
    maxFlips
};

fn main() -> i64 = fannkuch();

// Fannkuch-redux benchmark - MODERN VERSION
// v0.60.24: Uses all modern BMB features
// - Stack arrays [i64; 12] with array-to-pointer cast
// - Native pointer syntax ptr[i] and set ptr[i] = val
// - For loops for i in 0..n
// - Bit shift for checksum calculation

fn max_val(a: i64, b: i64) -> i64 = if a > b { a } else { b };

// Swap elements using native pointer syntax
fn swap(arr: *i64, i: i64, j: i64) -> i64 = {
    let tmp = arr[i];
    set arr[i] = arr[j];
    set arr[j] = tmp;
    0
};

fn fannkuch(n: i64) -> i64 = {
    // Stack-allocated arrays (max n=12)
    let perm_arr: [i64; 12] = [0; 12];
    let perm1_arr: [i64; 12] = [0; 12];
    let count_arr: [i64; 12] = [0; 12];

    // Cast to pointers for function use
    let perm = perm_arr as *i64;
    let perm1 = perm1_arr as *i64;
    let count = count_arr as *i64;

    let mut maxFlips: i64 = 0;
    let mut checksum: i64 = 0;
    let mut permCount: i64 = 0;

    // Initialize arrays using for loop
    for i in 0..n {
        let _a = { set perm1[i] = i; 0 };
        set count[i] = i + 1
    };

    let mut running: i64 = 1;

    // Main permutation loop
    while running != 0 {
        // Copy perm1 to perm using for loop
        for i in 0..n {
            set perm[i] = perm1[i]
        };

        // Count flips
        let mut flips: i64 = 0;
        let mut first = perm[0];
        while first != 0 {
            // Reverse prefix
            let mut lo: i64 = 0;
            let mut hi = first;
            while lo < hi {
                swap(perm, lo, hi);
                { lo = lo + 1 };
                { hi = hi - 1 };
            };
            { flips = flips + 1 };
            { first = perm[0] };
        };

        // Update results - use band for parity check
        { maxFlips = max_val(maxFlips, flips) };
        // (permCount band 1) == 0 means even -> add flips, odd -> subtract
        let delta = if (permCount band 1) == 0 { flips } else { 0 - flips };
        { checksum = checksum + delta };

        // Generate next permutation (Heap's algorithm variant)
        { running = 0 };
        let mut i: i64 = 1;
        while i < n {
            // Rotate: perm1[0..=i] left by 1
            let tmp = perm1[0];
            let mut j: i64 = 0;
            while j < i {
                set perm1[j] = perm1[j + 1];
                { j = j + 1 };
            };
            set perm1[i] = tmp;

            let c = count[i] - 1;
            set count[i] = c;
            if c > 0 {
                let _r = { running = 1 };
                let _p = { permCount = permCount + 1 };
                break
            } else {
                let _s = { set count[i] = i + 1; 0 };
                { i = i + 1 }
            }
        };
    };

    let p = println(checksum);
    maxFlips
};

fn main() -> i64 = {
    let n = 10;
    let result = fannkuch(n);
    let p = println(result);
    0
};

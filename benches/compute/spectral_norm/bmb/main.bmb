// Spectral norm benchmark - STACK ARRAY VERSION v0.60.123
// v0.60.23: Uses fixed-size stack arrays [f64; 1000] with array-to-pointer cast
// - N = 1000 (compile-time constant)
// - 10 iterations (same as C)
// - Stack-allocated arrays for better cache performance
// - Native pointer syntax for array access
// v0.60.123: Add @const to ITERATIONS

// Constants
// v0.60.52: Increased from 10 to 30 for stable measurement (target: ~111ms)
@const fn ITERATIONS() -> i64 = 30;

// A(i,j) = 1 / ((i+j)(i+j+1)/2 + i + 1)
// v0.60.45: Inline for better loop performance
@inline
fn matrix_a(i: i64, j: i64) -> f64 = {
    let sum = i + j;
    let denom = (sum * (sum + 1)) / 2 + i + 1;
    1.0 / i64_to_f64(denom)
};

// Initialize vector with 1.0 using native pointer
@inline
fn init_ones(v: *f64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        set v[i] = 1.0;
        { i = i + 1 };
    };
    0
};

// mult_Av: Av[i] = sum_j(A(i,j) * v[j])
@inline
fn mult_av(v: *f64, av: *f64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        let mut j: i64 = 0;
        let mut sum: f64 = 0.0;
        while j < n {
            let a_ij = matrix_a(i, j);
            let v_j = v[j];
            { sum = sum + a_ij * v_j };
            { j = j + 1 };
        };
        set av[i] = sum;
        { i = i + 1 };
    };
    0
};

// mult_Atv: Atv[i] = sum_j(A(j,i) * v[j])
@inline
fn mult_atv(v: *f64, atv: *f64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < n {
        let mut j: i64 = 0;
        let mut sum: f64 = 0.0;
        while j < n {
            let a_ji = matrix_a(j, i);  // Note: A(j,i) not A(i,j)
            let v_j = v[j];
            { sum = sum + a_ji * v_j };
            { j = j + 1 };
        };
        set atv[i] = sum;
        { i = i + 1 };
    };
    0
};

// mult_AtAv: computes A^T * A * v
@inline
fn mult_atav(v: *f64, atav: *f64, temp: *f64, n: i64) -> i64 = {
    let m1 = mult_av(v, temp, n);
    mult_atv(temp, atav, n)
};

// Run power iterations
fn power_iterations(u: *f64, v: *f64, temp: *f64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < ITERATIONS() {
        let m1 = mult_atav(u, v, temp, n);
        let m2 = mult_atav(v, u, temp, n);
        { i = i + 1 };
    };
    0
};

// Compute vBv = sum_i(u[i] * v[i])
fn compute_vbv(u: *f64, v: *f64, n: i64) -> f64 = {
    let mut i: i64 = 0;
    let mut acc: f64 = 0.0;
    while i < n {
        let u_i = u[i];
        let v_i = v[i];
        { acc = acc + u_i * v_i };
        { i = i + 1 };
    };
    acc
};

// Compute vv = sum_i(v[i] * v[i])
fn compute_vv(v: *f64, n: i64) -> f64 = {
    let mut i: i64 = 0;
    let mut acc: f64 = 0.0;
    while i < n {
        let v_i = v[i];
        { acc = acc + v_i * v_i };
        { i = i + 1 };
    };
    acc
};

fn main() -> i64 = {
    // Use compile-time constant for stack allocation
    let n: i64 = 1000;

    // Stack-allocated vectors using [val; N] repeat syntax
    let u: [f64; 1000] = [0.0; 1000];
    let v: [f64; 1000] = [0.0; 1000];
    let temp: [f64; 1000] = [0.0; 1000];

    // Cast arrays to pointers (v0.60.23: array decay)
    let u_ptr = u as *f64;
    let v_ptr = v as *f64;
    let temp_ptr = temp as *f64;

    // Initialize u with 1.0
    let init = init_ones(u_ptr, n);

    // Run power iterations
    let iter = power_iterations(u_ptr, v_ptr, temp_ptr, n);

    // Compute result: sqrt(vBv / vv)
    let vbv = compute_vbv(u_ptr, v_ptr, n);
    let vv = compute_vv(v_ptr, n);
    let result = sqrt(vbv / vv);

    // v0.60.44: Use println_f64 for proper float output
    let p = println_f64(result);

    0
};

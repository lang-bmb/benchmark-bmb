// Mandelbrot set computation benchmark
// Measures: floating-point arithmetic (simulated with fixed-point), loops

// Fixed-point scale: 10000 = 1.0
fn scale() -> i64 = 10000;

// Multiply fixed-point numbers
fn mul_fp(a: i64, b: i64) -> i64 = (a * b) / scale();

// Square
fn square_fp(x: i64) -> i64 = mul_fp(x, x);

// Check if point escapes Mandelbrot set
fn iterate(cr: i64, ci: i64, zr: i64, zi: i64, iter: i64, max_iter: i64) -> i64 =
    if iter >= max_iter { max_iter } else {
        let zr2 = square_fp(zr);
        let zi2 = square_fp(zi);
        let mag = zr2 + zi2;
        if mag > 4 * scale() * scale() { iter } else {
            let new_zr = zr2 - zi2 + cr;
            let new_zi = 2 * mul_fp(zr, zi) + ci;
            iterate(cr, ci, new_zr, new_zi, iter + 1, max_iter)
        }
    };

fn mandelbrot_point(x: i64, y: i64, width: i64, height: i64, max_iter: i64) -> i64 = {
    let cr = (x * 4 * scale() / width) - 2 * scale();
    let ci = (y * 4 * scale() / height) - 2 * scale();
    iterate(cr, ci, 0, 0, 0, max_iter)
};

// Count escaping points in a region
fn count_region(x: i64, y: i64, width: i64, height: i64, max_iter: i64, acc: i64) -> i64 =
    if y >= height { acc } else if x >= width {
        count_region(0, y + 1, width, height, max_iter, acc)
    } else {
        let result = mandelbrot_point(x, y, width, height, max_iter);
        let delta = if result < max_iter { 1 } else { 0 };
        count_region(x + 1, y, width, height, max_iter, acc + delta)
    };

fn main() -> i64 = {
    let size = 50;
    let max_iter = 50;
    count_region(0, 0, size, size, max_iter, 0)
};

// Regex-Redux - Pattern matching benchmark
// Measures: String processing, pattern matching, memory allocation
//
// NOTE: BMB does not have regex library yet
// This is a simplified version using manual pattern matching
//
// Reference: Computer Language Benchmarks Game
// https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/regexredux.html

// Simple string buffer using malloc - v0.60.123: add @inline
@inline fn buffer_new(size: i64) -> i64 = malloc(size);
@inline fn buffer_free(buf: i64) -> i64 = { let _f = free(buf); 0 };
@inline fn buffer_get(buf: i64, i: i64) -> i64 = load_u8(buf + i);
@inline fn buffer_set(buf: i64, i: i64, val: i64) -> i64 = { let _s = store_u8(buf + i, val); 0 };

// Character constants - use @const for compile-time evaluation
@const fn CHAR_A() -> i64 = 65;  // 'A'
@const fn CHAR_C() -> i64 = 67;  // 'C'
@const fn CHAR_G() -> i64 = 71;  // 'G'
@const fn CHAR_T() -> i64 = 84;  // 'T'
@const fn CHAR_a() -> i64 = 97;  // 'a'
@const fn CHAR_c() -> i64 = 99;  // 'c'
@const fn CHAR_g() -> i64 = 103; // 'g'
@const fn CHAR_t() -> i64 = 116; // 't'

// Check if character matches [cgt] or [CGT]
@inline
fn is_cgt(ch: i64) -> i64 = {
    if ch == CHAR_c() { 1 }
    else if ch == CHAR_g() { 1 }
    else if ch == CHAR_t() { 1 }
    else if ch == CHAR_C() { 1 }
    else if ch == CHAR_G() { 1 }
    else if ch == CHAR_T() { 1 }
    else { 0 }
};

// Check if character matches [acg] or [ACG]
@inline
fn is_acg(ch: i64) -> i64 = {
    if ch == CHAR_a() { 1 }
    else if ch == CHAR_c() { 1 }
    else if ch == CHAR_g() { 1 }
    else if ch == CHAR_A() { 1 }
    else if ch == CHAR_C() { 1 }
    else if ch == CHAR_G() { 1 }
    else { 0 }
};

// Check if character matches [act] or [ACT]
@inline
fn is_act(ch: i64) -> i64 = {
    if ch == CHAR_a() { 1 }
    else if ch == CHAR_c() { 1 }
    else if ch == CHAR_t() { 1 }
    else if ch == CHAR_A() { 1 }
    else if ch == CHAR_C() { 1 }
    else if ch == CHAR_T() { 1 }
    else { 0 }
};

// Match pattern "agggtaaa" at position
@inline
fn match_agggtaaa(buf: i64, pos: i64, len: i64) -> i64 = {
    if pos + 8 > len { 0 }
    else {
        let c0 = buffer_get(buf, pos);
        let c1 = buffer_get(buf, pos + 1);
        let c2 = buffer_get(buf, pos + 2);
        let c3 = buffer_get(buf, pos + 3);
        let c4 = buffer_get(buf, pos + 4);
        let c5 = buffer_get(buf, pos + 5);
        let c6 = buffer_get(buf, pos + 6);
        let c7 = buffer_get(buf, pos + 7);

        if (c0 == CHAR_a() || c0 == CHAR_A()) &&
           (c1 == CHAR_g() || c1 == CHAR_G()) &&
           (c2 == CHAR_g() || c2 == CHAR_G()) &&
           (c3 == CHAR_g() || c3 == CHAR_G()) &&
           (c4 == CHAR_t() || c4 == CHAR_T()) &&
           (c5 == CHAR_a() || c5 == CHAR_A()) &&
           (c6 == CHAR_a() || c6 == CHAR_A()) &&
           (c7 == CHAR_a() || c7 == CHAR_A())
        { 1 }
        else { 0 }
    }
};

// Match pattern "tttaccct" at position
@inline
fn match_tttaccct(buf: i64, pos: i64, len: i64) -> i64 = {
    if pos + 8 > len { 0 }
    else {
        let c0 = buffer_get(buf, pos);
        let c1 = buffer_get(buf, pos + 1);
        let c2 = buffer_get(buf, pos + 2);
        let c3 = buffer_get(buf, pos + 3);
        let c4 = buffer_get(buf, pos + 4);
        let c5 = buffer_get(buf, pos + 5);
        let c6 = buffer_get(buf, pos + 6);
        let c7 = buffer_get(buf, pos + 7);

        if (c0 == CHAR_t() || c0 == CHAR_T()) &&
           (c1 == CHAR_t() || c1 == CHAR_T()) &&
           (c2 == CHAR_t() || c2 == CHAR_T()) &&
           (c3 == CHAR_a() || c3 == CHAR_A()) &&
           (c4 == CHAR_c() || c4 == CHAR_C()) &&
           (c5 == CHAR_c() || c5 == CHAR_C()) &&
           (c6 == CHAR_c() || c6 == CHAR_C()) &&
           (c7 == CHAR_t() || c7 == CHAR_T())
        { 1 }
        else { 0 }
    }
};

// Count pattern matches in buffer using while loop (v0.60.262)
fn count_pattern1(buf: i64, len: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut count: i64 = 0;
    while i < len {
        let m1 = match_agggtaaa(buf, i, len);
        let m2 = match_tttaccct(buf, i, len);
        { count = count + m1 + m2; i = i + 1 }
    };
    count
};

// Generate test DNA sequence using while loop (v0.60.262)
fn generate_dna_loop(buf: i64, len: i64) -> i64 = {
    let mut i: i64 = 0;
    while i < len {
        // Simple PRNG for DNA generation
        let seed = i * 1103515245 + 12345;
        let base_idx = (seed / 65536) % 4;

        let ch = if base_idx == 0 { CHAR_A() }
                 else if base_idx == 1 { CHAR_C() }
                 else if base_idx == 2 { CHAR_G() }
                 else { CHAR_T() };

        let _s = buffer_set(buf, i, ch);
        { i = i + 1 }
    };
    0
};

fn generate_dna(buf: i64, len: i64) -> i64 = {
    let _gen = generate_dna_loop(buf, len);

    // Insert some known patterns for testing
    let _s0 = buffer_set(buf, 100, CHAR_a());
    let _s1 = buffer_set(buf, 101, CHAR_g());
    let _s2 = buffer_set(buf, 102, CHAR_g());
    let _s3 = buffer_set(buf, 103, CHAR_g());
    let _s4 = buffer_set(buf, 104, CHAR_t());
    let _s5 = buffer_set(buf, 105, CHAR_a());
    let _s6 = buffer_set(buf, 106, CHAR_a());
    let _s7 = buffer_set(buf, 107, CHAR_a());

    0
};

fn main() -> i64 = {
    let seq_len: i64 = 100000;

    // Allocate and generate DNA sequence
    let buf = buffer_new(seq_len);
    let _gen = generate_dna(buf, seq_len);

    // Count pattern matches
    let count1 = count_pattern1(buf, seq_len);

    let _p1 = print_str("agggtaaa|tttaccct ");
    let _p2 = println(count1);

    // Free buffer
    let _free = buffer_free(buf);

    0
};

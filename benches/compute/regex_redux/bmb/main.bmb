// Regex-Redux - Pattern matching benchmark
// Measures: String processing, pattern matching, memory allocation
//
// NOTE: BMB does not have regex library yet
// This is a simplified version using manual pattern matching
//
// Reference: Computer Language Benchmarks Game
// https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/regexredux.html

// DNA sequence patterns to match (simplified)
// Original patterns:
// agggtaaa|tttaccct
// [cgt]gggtaaa|tttaccc[acg]
// a[act]ggtaaa|tttacc[agt]t
// ag[act]gtaaa|tttac[agt]ct
// agg[act]taaa|ttta[agt]cct
// aggg[acg]aaa|ttt[cgt]ccct
// agggt[cgt]aa|tt[acg]accct
// agggta[cgt]a|t[acg]taccct
// agggtaa[cgt]|[acg]ttaccct

// Simple string buffer using malloc
fn buffer_new(size: i64) -> i64 = malloc(size);
fn buffer_free(buf: i64) -> i64 = { free(buf); 0 };
fn buffer_get(buf: i64, i: i64) -> i64 = load_i8(buf + i);
fn buffer_set(buf: i64, i: i64, val: i64) -> i64 = { store_i8(buf + i, val); 0 };

// Character constants
fn CHAR_A() -> i64 = 65;  // 'A'
fn CHAR_C() -> i64 = 67;  // 'C'
fn CHAR_G() -> i64 = 71;  // 'G'
fn CHAR_T() -> i64 = 84;  // 'T'
fn CHAR_a() -> i64 = 97;  // 'a'
fn CHAR_c() -> i64 = 99;  // 'c'
fn CHAR_g() -> i64 = 103; // 'g'
fn CHAR_t() -> i64 = 116; // 't'

// Check if character matches [cgt] or [CGT]
fn is_cgt(ch: i64) -> i64 = {
    if ch == CHAR_c() { 1 }
    else if ch == CHAR_g() { 1 }
    else if ch == CHAR_t() { 1 }
    else if ch == CHAR_C() { 1 }
    else if ch == CHAR_G() { 1 }
    else if ch == CHAR_T() { 1 }
    else { 0 }
};

// Check if character matches [acg] or [ACG]
fn is_acg(ch: i64) -> i64 = {
    if ch == CHAR_a() { 1 }
    else if ch == CHAR_c() { 1 }
    else if ch == CHAR_g() { 1 }
    else if ch == CHAR_A() { 1 }
    else if ch == CHAR_C() { 1 }
    else if ch == CHAR_G() { 1 }
    else { 0 }
};

// Check if character matches [act] or [ACT]
fn is_act(ch: i64) -> i64 = {
    if ch == CHAR_a() { 1 }
    else if ch == CHAR_c() { 1 }
    else if ch == CHAR_t() { 1 }
    else if ch == CHAR_A() { 1 }
    else if ch == CHAR_C() { 1 }
    else if ch == CHAR_T() { 1 }
    else { 0 }
};

// Match pattern "agggtaaa" at position
fn match_agggtaaa(buf: i64, pos: i64, len: i64) -> i64 = {
    if pos + 8 > len { 0 }
    else {
        let c0 = buffer_get(buf, pos);
        let c1 = buffer_get(buf, pos + 1);
        let c2 = buffer_get(buf, pos + 2);
        let c3 = buffer_get(buf, pos + 3);
        let c4 = buffer_get(buf, pos + 4);
        let c5 = buffer_get(buf, pos + 5);
        let c6 = buffer_get(buf, pos + 6);
        let c7 = buffer_get(buf, pos + 7);

        if (c0 == CHAR_a() || c0 == CHAR_A()) &&
           (c1 == CHAR_g() || c1 == CHAR_G()) &&
           (c2 == CHAR_g() || c2 == CHAR_G()) &&
           (c3 == CHAR_g() || c3 == CHAR_G()) &&
           (c4 == CHAR_t() || c4 == CHAR_T()) &&
           (c5 == CHAR_a() || c5 == CHAR_A()) &&
           (c6 == CHAR_a() || c6 == CHAR_A()) &&
           (c7 == CHAR_a() || c7 == CHAR_A())
        { 1 }
        else { 0 }
    }
};

// Match pattern "tttaccct" at position
fn match_tttaccct(buf: i64, pos: i64, len: i64) -> i64 = {
    if pos + 8 > len { 0 }
    else {
        let c0 = buffer_get(buf, pos);
        let c1 = buffer_get(buf, pos + 1);
        let c2 = buffer_get(buf, pos + 2);
        let c3 = buffer_get(buf, pos + 3);
        let c4 = buffer_get(buf, pos + 4);
        let c5 = buffer_get(buf, pos + 5);
        let c6 = buffer_get(buf, pos + 6);
        let c7 = buffer_get(buf, pos + 7);

        if (c0 == CHAR_t() || c0 == CHAR_T()) &&
           (c1 == CHAR_t() || c1 == CHAR_T()) &&
           (c2 == CHAR_t() || c2 == CHAR_T()) &&
           (c3 == CHAR_a() || c3 == CHAR_A()) &&
           (c4 == CHAR_c() || c4 == CHAR_C()) &&
           (c5 == CHAR_c() || c5 == CHAR_C()) &&
           (c6 == CHAR_c() || c6 == CHAR_C()) &&
           (c7 == CHAR_t() || c7 == CHAR_T())
        { 1 }
        else { 0 }
    }
};

// Count pattern matches in buffer
fn count_pattern1(buf: i64, len: i64) -> i64 = {
    let mut count: i64 = 0;
    let mut i: i64 = 0;

    while i < len {
        if match_agggtaaa(buf, i, len) == 1 {
            { count = count + 1 };
        };
        if match_tttaccct(buf, i, len) == 1 {
            { count = count + 1 };
        };
        { i = i + 1 };
    };

    count
};

// Generate test DNA sequence
fn generate_dna(buf: i64, len: i64) -> i64 = {
    let mut i: i64 = 0;
    let bases = "ACGT";

    while i < len {
        // Simple PRNG for DNA generation
        let seed = i * 1103515245 + 12345;
        let base_idx = (seed / 65536) % 4;

        let ch = if base_idx == 0 { CHAR_A() }
                 else if base_idx == 1 { CHAR_C() }
                 else if base_idx == 2 { CHAR_G() }
                 else { CHAR_T() };

        buffer_set(buf, i, ch);
        { i = i + 1 };
    };

    // Insert some known patterns for testing
    buffer_set(buf, 100, CHAR_a());
    buffer_set(buf, 101, CHAR_g());
    buffer_set(buf, 102, CHAR_g());
    buffer_set(buf, 103, CHAR_g());
    buffer_set(buf, 104, CHAR_t());
    buffer_set(buf, 105, CHAR_a());
    buffer_set(buf, 106, CHAR_a());
    buffer_set(buf, 107, CHAR_a());

    0
};

fn main() -> i64 = {
    let seq_len: i64 = 100000;

    // Allocate and generate DNA sequence
    let buf = buffer_new(seq_len);
    let _gen = generate_dna(buf, seq_len);

    // Count pattern matches
    let count1 = count_pattern1(buf, seq_len);

    let _p1 = print_str("agggtaaa|tttaccct ");
    let _p2 = println(count1);

    // Free buffer
    let _free = buffer_free(buf);

    0
};

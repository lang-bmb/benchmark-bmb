// Hash Table benchmark - WHILE LOOP VERSION
// v0.51.7: Rewritten with while loops for optimal LLVM optimization
// Measures: hashmap insert, lookup, and delete operations

// Number of operations (same as C: 100000)
fn get_n() -> i64 = 100000;

// Sentinel value for "not found" (i64::MIN equivalent)
fn not_found() -> i64 = 0 - 9223372036854775807 - 1;

// Simple pseudo-random number generator (linear congruential)
fn random_next(seed: i64) -> i64 =
    (seed * 1103515245 + 12345) % 2147483648;

// Insert N key-value pairs into hashmap
fn benchmark_insert(m: i64, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    while i < n {
        let key = s % 1000000;
        let value = key * 7;
        let _r = hashmap_insert(m, key, value);
        { s = random_next(s) };
        { i = i + 1 };
    };
    s
};

// Lookup N keys from hashmap
fn benchmark_lookup(m: i64, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    let mut found: i64 = 0;
    while i < n {
        let key = s % 1000000;
        let result = hashmap_get(m, key);
        let is_found = if result != not_found() { 1 } else { 0 };
        { found = found + is_found };
        { s = random_next(s) };
        { i = i + 1 };
    };
    found
};

// Delete N keys from hashmap
fn benchmark_delete(m: i64, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    let mut deleted: i64 = 0;
    while i < n {
        let key = s % 1000000;
        let result = hashmap_remove(m, key);
        let was_deleted = if result != not_found() { 1 } else { 0 };
        { deleted = deleted + was_deleted };
        { s = random_next(s) };
        { i = i + 1 };
    };
    deleted
};

fn main() -> i64 = {
    let n = get_n();
    let seed = 42;

    // Create hashmap
    let m = hashmap_new();

    // Phase 1: Insert operations
    let seed1 = benchmark_insert(m, n, seed);
    let len1 = hashmap_len(m);
    let _p1 = println(len1);

    // Phase 2: Lookup operations (same seed = same keys)
    let found = benchmark_lookup(m, n, seed);
    let _p2 = println(found);

    // Phase 3: Delete half the entries (different seed)
    let deleted = benchmark_delete(m, n / 2, random_next(seed));
    let len2 = hashmap_len(m);
    let _p3 = println(len2);

    // Cleanup
    let _f = hashmap_free(m);

    // Return final length as verification
    let result = len2;
    let _u = println(result);
    0
};

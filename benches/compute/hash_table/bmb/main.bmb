// Hash Table benchmark - STRUCT + WHILE LOOP VERSION v0.60.61
// v0.60.61: Use while loops instead of recursion for better LLVM optimization
// Layout: [count:i64][entries...]

fn table_size() -> i64 = 131072;
fn get_n() -> i64 = 100000;
fn not_found() -> i64 = 0 - 9223372036854775807 - 1;

// Entry structure (3 i64 values = 24 bytes)
struct Entry {
    key: i64,
    value: i64,
    state: i64
}

// HashMap structure to eliminate inttoptr for count access
struct HashMap {
    count: i64,
    capacity: i64
}

@inline
fn hash_i64(key: i64) -> i64 = {
    let h = key * 5871781006564002453;
    h bxor (h >> 32)
};

// Allocate HashMap: struct (16 bytes) + entries array
fn hm_new() -> *HashMap = {
    // Allocate: 16 bytes for HashMap struct + entries
    let total = 16 + table_size() * 24;
    let m = calloc(1, total) as *HashMap;
    let _c = set m.count = 0;
    let _cap = set m.capacity = table_size();
    m
};

fn hm_free(m: *HashMap) -> i64 = { let _u = free(m as i64); 0 };

fn random_next(seed: i64) -> i64 = (seed * 1103515245 + 12345) % 2147483648;

// Get entries base pointer (after HashMap struct at offset 16)
fn hm_entries(m: *HashMap) -> *Entry = (m as i64 + 16) as *Entry;

// Get entry at index
fn entry_at(m: *HashMap, idx: i64) -> *Entry = hm_entries(m) + idx;

// ============================================================================
// Insert with while loop (v0.60.61)
// ============================================================================
fn hm_insert(m: *HashMap, key: i64, value: i64) -> i64 = {
    let hash = hash_i64(key);
    let cap = m.capacity;
    let mask = cap - 1;
    let mut idx: i64 = hash band mask;
    let mut i: i64 = 0;
    let mut result: i64 = 0;

    while i < cap {
        let e = entry_at(m, idx);
        let state = e.state;
        if state == 0 or state == 2 {
            let _s1 = set e.key = key;
            let _s2 = set e.value = value;
            let _s3 = set e.state = 1;
            let _c = set m.count = m.count + 1;
            let _r = { result = 1 };
            { i = cap }
        } else if state == 1 and e.key == key {
            let _s = set e.value = value;
            let _r = { result = 0 };
            { i = cap }
        } else {
            let _x = { idx = (idx + 1) band mask };
            { i = i + 1 }
        }
    };
    result
};

// ============================================================================
// Get with while loop (v0.60.61)
// ============================================================================
fn hm_get(m: *HashMap, key: i64) -> i64 = {
    let hash = hash_i64(key);
    let cap = m.capacity;
    let mask = cap - 1;
    let mut idx: i64 = hash band mask;
    let mut i: i64 = 0;
    let mut result: i64 = not_found();

    while i < cap {
        let e = entry_at(m, idx);
        let state = e.state;
        if state == 0 {
            { i = cap }
        } else if state == 1 and e.key == key {
            let _r = { result = e.value };
            { i = cap }
        } else {
            let _x = { idx = (idx + 1) band mask };
            { i = i + 1 }
        }
    };
    result
};

// ============================================================================
// Remove with while loop (v0.60.61)
// ============================================================================
fn hm_remove(m: *HashMap, key: i64) -> i64 = {
    let hash = hash_i64(key);
    let cap = m.capacity;
    let mask = cap - 1;
    let mut idx: i64 = hash band mask;
    let mut i: i64 = 0;
    let mut result: i64 = 0;

    while i < cap {
        let e = entry_at(m, idx);
        let state = e.state;
        if state == 0 {
            { i = cap }
        } else if state == 1 and e.key == key {
            let _s = set e.state = 2;
            let _c = set m.count = m.count - 1;
            let _r = { result = 1 };
            { i = cap }
        } else {
            let _x = { idx = (idx + 1) band mask };
            { i = i + 1 }
        }
    };
    result
};

// ============================================================================
// Benchmark functions
// ============================================================================
fn benchmark_insert(m: *HashMap, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    while i < n {
        let key = s % 1000000;
        let value = key * 7;
        let _r = hm_insert(m, key, value);
        { s = random_next(s) };
        { i = i + 1 }
    };
    s
};

fn benchmark_lookup(m: *HashMap, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    let mut found: i64 = 0;
    while i < n {
        let key = s % 1000000;
        let result = hm_get(m, key);
        let is_found = if result != not_found() { 1 } else { 0 };
        { found = found + is_found };
        { s = random_next(s) };
        { i = i + 1 }
    };
    found
};

fn benchmark_delete(m: *HashMap, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    let mut deleted: i64 = 0;
    while i < n {
        let key = s % 1000000;
        let result = hm_remove(m, key);
        { deleted = deleted + result };
        { s = random_next(s) };
        { i = i + 1 }
    };
    deleted
};

fn run_iteration(n: i64, seed: i64, iter: i64, total_found: i64) -> i64 =
    if iter >= 30 { total_found }
    else {
        let m = hm_new();
        let _seed1 = benchmark_insert(m, n, seed);
        let found = benchmark_lookup(m, n, seed);
        let _deleted = benchmark_delete(m, n / 2, random_next(seed));
        let _f = hm_free(m);
        run_iteration(n, seed, iter + 1, total_found + found)
    };

fn main() -> i64 = {
    let n = get_n();
    let seed = 42;

    // Run 30 iterations for stable measurement
    let total_found = run_iteration(n, seed, 0, 0);

    // Print final results
    let m = hm_new();
    let _seed1 = benchmark_insert(m, n, seed);
    let len1 = m.count;
    let _p1 = println(len1);

    let found = benchmark_lookup(m, n, seed);
    let _p2 = println(found);

    let _deleted = benchmark_delete(m, n / 2, random_next(seed));
    let len2 = m.count;
    let _p3 = println(len2);

    let _f = hm_free(m);
    0
};

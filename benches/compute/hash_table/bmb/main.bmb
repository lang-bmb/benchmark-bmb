// Hash Table benchmark v0.60.66
// v0.60.66: Use pointer field for entries (like C) to avoid inttoptr

fn table_size() -> i64 = 131072;
fn get_n() -> i64 = 100000;
fn not_found() -> i64 = 0 - 9223372036854775807 - 1;

// Entry structure (24 bytes: 2 i64 + 1 i32 + 4 padding)
struct Entry {
    key: i64,
    value: i64,
    state: i32
}

// HashMap with pointer to entries array (like C)
struct HashMap {
    entries: *Entry,
    count: i64,
    capacity: i64
}

@inline
fn hash_i64(key: i64) -> i64 = {
    let h = key * 5871781006564002453;
    h bxor (h >> 32)
};

// Allocate HashMap: separate struct and entries array (like C)
fn hm_new() -> *HashMap = {
    let m = malloc(24) as *HashMap;  // 24 bytes for HashMap struct
    let entries = calloc(table_size(), 24) as *Entry;  // entries array
    let _e = set m.entries = entries;
    let _c = set m.count = 0;
    let _cap = set m.capacity = table_size();
    m
};

fn hm_free(m: *HashMap) -> i64 = {
    let _e = free(m.entries as i64);
    let _m = free(m as i64);
    0
};

fn random_next(seed: i64) -> i64 = (seed * 1103515245 + 12345) % 2147483648;

// ============================================================================
// Insert with while loop
// ============================================================================
fn hm_insert(m: *HashMap, key: i64, value: i64) -> i64 = {
    let hash = hash_i64(key);
    let cap = m.capacity;
    let mask = cap - 1;
    let entries = m.entries;
    let mut idx: i64 = hash band mask;
    let mut i: i64 = 0;
    let mut result: i64 = 0;

    while i < cap {
        let e = entries + idx;
        let state = e.state;
        if state == 0 or state == 2 {
            let _s1 = set e.key = key;
            let _s2 = set e.value = value;
            let _s3 = set e.state = 1;
            let _c = set m.count = m.count + 1;
            let _r = { result = 1 };
            { i = cap }
        } else if state == 1 and e.key == key {
            let _s = set e.value = value;
            let _r = { result = 0 };
            { i = cap }
        } else {
            let _x = { idx = (idx + 1) band mask };
            { i = i + 1 }
        }
    };
    result
};

// ============================================================================
// Get with while loop
// ============================================================================
fn hm_get(m: *HashMap, key: i64) -> i64 = {
    let hash = hash_i64(key);
    let cap = m.capacity;
    let mask = cap - 1;
    let entries = m.entries;
    let mut idx: i64 = hash band mask;
    let mut i: i64 = 0;
    let mut result: i64 = not_found();

    while i < cap {
        let e = entries + idx;
        let state = e.state;
        if state == 0 {
            { i = cap }
        } else if state == 1 and e.key == key {
            let _r = { result = e.value };
            { i = cap }
        } else {
            let _x = { idx = (idx + 1) band mask };
            { i = i + 1 }
        }
    };
    result
};

// ============================================================================
// Remove with while loop
// ============================================================================
fn hm_remove(m: *HashMap, key: i64) -> i64 = {
    let hash = hash_i64(key);
    let cap = m.capacity;
    let mask = cap - 1;
    let entries = m.entries;
    let mut idx: i64 = hash band mask;
    let mut i: i64 = 0;
    let mut result: i64 = 0;

    while i < cap {
        let e = entries + idx;
        let state = e.state;
        if state == 0 {
            { i = cap }
        } else if state == 1 and e.key == key {
            let _s = set e.state = 2;
            let _c = set m.count = m.count - 1;
            let _r = { result = 1 };
            { i = cap }
        } else {
            let _x = { idx = (idx + 1) band mask };
            { i = i + 1 }
        }
    };
    result
};

// ============================================================================
// Benchmark functions
// ============================================================================
fn benchmark_insert(m: *HashMap, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    while i < n {
        let key = s % 1000000;
        let value = key * 7;
        let _r = hm_insert(m, key, value);
        { s = random_next(s) };
        { i = i + 1 }
    };
    s
};

fn benchmark_lookup(m: *HashMap, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    let mut found: i64 = 0;
    while i < n {
        let key = s % 1000000;
        let result = hm_get(m, key);
        let is_found = if result != not_found() { 1 } else { 0 };
        { found = found + is_found };
        { s = random_next(s) };
        { i = i + 1 }
    };
    found
};

fn benchmark_delete(m: *HashMap, n: i64, seed: i64) -> i64 = {
    let mut i: i64 = 0;
    let mut s: i64 = seed;
    let mut deleted: i64 = 0;
    while i < n {
        let key = s % 1000000;
        let result = hm_remove(m, key);
        { deleted = deleted + result };
        { s = random_next(s) };
        { i = i + 1 }
    };
    deleted
};

fn main() -> i64 = {
    let n = get_n();
    let seed = 42;

    // 30 iterations with while loop (like C)
    let mut iter: i64 = 0;
    let mut total_found: i64 = 0;
    while iter < 30 {
        let m = hm_new();
        let _seed1 = benchmark_insert(m, n, seed);
        let found = benchmark_lookup(m, n, seed);
        let _deleted = benchmark_delete(m, n / 2, random_next(seed));
        let _f = hm_free(m);
        { total_found = total_found + found };
        { iter = iter + 1 }
    };

    let m = hm_new();
    let _seed1 = benchmark_insert(m, n, seed);
    let len1 = m.count;
    let _p1 = println(len1);

    let found = benchmark_lookup(m, n, seed);
    let _p2 = println(found);

    let _deleted = benchmark_delete(m, n / 2, random_next(seed));
    let len2 = m.count;
    let _p3 = println(len2);

    let _f = hm_free(m);
    0
};

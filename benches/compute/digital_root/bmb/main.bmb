// Digital Root Benchmark v0.60.123
// v0.60.123: Add @inline to prevent parameter narrowing overhead
// v0.60.62: Use while loops instead of recursion

@inline
fn digit_sum(n: i64) -> i64 = {
    let mut num: i64 = n;
    let mut acc: i64 = 0;
    while num > 0 {
        { acc = acc + num % 10 };
        { num = num / 10 }
    };
    acc
};

@inline
fn digital_root(n: i64) -> i64 = {
    let mut num: i64 = n;
    while num >= 10 {
        { num = digit_sum(num) }
    };
    num
};

fn sum_digital_roots(n: i64) -> i64 = {
    let mut i: i64 = 1;
    let mut acc: i64 = 0;
    while i <= n {
        { acc = acc + digital_root(i) };
        { i = i + 1 }
    };
    acc
};

fn main() -> i64 = {
    // Sum digital roots from 1 to 100000, 10 iterations
    let mut result: i64 = 0;
    let mut iter: i64 = 0;
    while iter < 10 {
        { result = result + sum_digital_roots(100000) };
        { iter = iter + 1 }
    };
    let _p = println(result);
    0
};

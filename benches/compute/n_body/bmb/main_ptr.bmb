// N-Body simulation benchmark - NATIVE POINTER VERSION (v0.60.19)
// Uses native pointer arithmetic: bodies + i instead of (bodies as i64 + i * 56) as *Body
// This enables LLVM's alias analysis for better optimization

// Constants
fn PI() -> f64 = 3.141592653589793;
fn SOLAR_MASS() -> f64 = 4.0 * PI() * PI();
fn DAYS_PER_YEAR() -> f64 = 365.24;
fn N_BODIES() -> i64 = 5;
fn N_STEPS() -> i64 = 2000000;

// Body structure (7 f64 values = 56 bytes)
struct Body {
    x: f64,
    y: f64,
    z: f64,
    vx: f64,
    vy: f64,
    vz: f64,
    mass: f64
}

// Allocate bodies array (5 bodies * 56 bytes = 280 bytes)
fn bodies_new() -> *Body = malloc(N_BODIES() * 56) as *Body;

// Get pointer to body at index i - NOW USING NATIVE POINTER ARITHMETIC
fn body_at(bodies: *Body, i: i64) -> *Body = bodies + i;

// Null pointer
fn null_body() -> *Body = 0 as *Body;

// Initialize all bodies
fn init_bodies(bodies: *Body) -> i64 = {
    // Sun (at origin)
    let sun = body_at(bodies, 0);
    let _s0 = set sun.x = 0.0;
    let _s1 = set sun.y = 0.0;
    let _s2 = set sun.z = 0.0;
    let _s3 = set sun.vx = 0.0;
    let _s4 = set sun.vy = 0.0;
    let _s5 = set sun.vz = 0.0;
    let _s6 = set sun.mass = SOLAR_MASS();

    // Jupiter
    let jupiter = body_at(bodies, 1);
    let _j0 = set jupiter.x = 4.84143144246472090e0;
    let _j1 = set jupiter.y = 0.0 - 1.16032004402742839e0;
    let _j2 = set jupiter.z = 0.0 - 1.03622044471123109e-1;
    let _j3 = set jupiter.vx = 1.66007664274403694e-3 * DAYS_PER_YEAR();
    let _j4 = set jupiter.vy = 7.69901118419740425e-3 * DAYS_PER_YEAR();
    let _j5 = set jupiter.vz = 0.0 - 6.90460016972063023e-5 * DAYS_PER_YEAR();
    let _j6 = set jupiter.mass = 9.54791938424326609e-4 * SOLAR_MASS();

    // Saturn
    let saturn = body_at(bodies, 2);
    let _sa0 = set saturn.x = 8.34336671824457987e0;
    let _sa1 = set saturn.y = 4.12479856412430479e0;
    let _sa2 = set saturn.z = 0.0 - 4.03523417114321381e-1;
    let _sa3 = set saturn.vx = 0.0 - 2.76742510726862411e-3 * DAYS_PER_YEAR();
    let _sa4 = set saturn.vy = 4.99852801234917238e-3 * DAYS_PER_YEAR();
    let _sa5 = set saturn.vz = 2.30417297573763929e-5 * DAYS_PER_YEAR();
    let _sa6 = set saturn.mass = 2.85885980666130812e-4 * SOLAR_MASS();

    // Uranus
    let uranus = body_at(bodies, 3);
    let _u0 = set uranus.x = 1.28943695621391310e1;
    let _u1 = set uranus.y = 0.0 - 1.51111514016986312e1;
    let _u2 = set uranus.z = 0.0 - 2.23307578892655734e-1;
    let _u3 = set uranus.vx = 2.96460137564761618e-3 * DAYS_PER_YEAR();
    let _u4 = set uranus.vy = 2.37847173959480950e-3 * DAYS_PER_YEAR();
    let _u5 = set uranus.vz = 0.0 - 2.96589568540237556e-5 * DAYS_PER_YEAR();
    let _u6 = set uranus.mass = 4.36624404335156298e-5 * SOLAR_MASS();

    // Neptune
    let neptune = body_at(bodies, 4);
    let _n0 = set neptune.x = 1.53796971148509165e1;
    let _n1 = set neptune.y = 0.0 - 2.59193146099879641e1;
    let _n2 = set neptune.z = 1.79258772950371181e-1;
    let _n3 = set neptune.vx = 2.68067772490389322e-3 * DAYS_PER_YEAR();
    let _n4 = set neptune.vy = 1.62824170038242295e-3 * DAYS_PER_YEAR();
    let _n5 = set neptune.vz = 0.0 - 9.51592254519715870e-5 * DAYS_PER_YEAR();
    let _n6 = set neptune.mass = 5.15138902046611451e-5 * SOLAR_MASS();

    0
};

// Compute momentum components
fn compute_px(bodies: *Body, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let b = body_at(bodies, i);
        compute_px(bodies, i + 1, acc + b.vx * b.mass)
    };

fn compute_py(bodies: *Body, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let b = body_at(bodies, i);
        compute_py(bodies, i + 1, acc + b.vy * b.mass)
    };

fn compute_pz(bodies: *Body, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let b = body_at(bodies, i);
        compute_pz(bodies, i + 1, acc + b.vz * b.mass)
    };

// Offset momentum (make total momentum zero)
fn offset_momentum(bodies: *Body) -> i64 = {
    let px = compute_px(bodies, 0, 0.0);
    let py = compute_py(bodies, 0, 0.0);
    let pz = compute_pz(bodies, 0, 0.0);
    let sun = body_at(bodies, 0);
    let _v1 = set sun.vx = 0.0 - px / SOLAR_MASS();
    let _v2 = set sun.vy = 0.0 - py / SOLAR_MASS();
    let _v3 = set sun.vz = 0.0 - pz / SOLAR_MASS();
    0
};

// Advance velocities (inner loop)
fn advance_velocities_inner(bodies: *Body, dt: f64, i: i64, j: i64) -> i64 =
    if j >= N_BODIES() { 0 }
    else {
        let bi = body_at(bodies, i);
        let bj = body_at(bodies, j);

        let dx = bi.x - bj.x;
        let dy = bi.y - bj.y;
        let dz = bi.z - bj.z;
        let dist_sq = dx * dx + dy * dy + dz * dz;
        let dist = sqrt(dist_sq);
        let mag = dt / (dist_sq * dist);

        let mi = bi.mass;
        let mj = bj.mass;

        let _vi1 = set bi.vx = bi.vx - dx * mj * mag;
        let _vi2 = set bi.vy = bi.vy - dy * mj * mag;
        let _vi3 = set bi.vz = bi.vz - dz * mj * mag;

        let _vj1 = set bj.vx = bj.vx + dx * mi * mag;
        let _vj2 = set bj.vy = bj.vy + dy * mi * mag;
        let _vj3 = set bj.vz = bj.vz + dz * mi * mag;

        advance_velocities_inner(bodies, dt, i, j + 1)
    };

// Advance velocities (outer loop)
fn advance_velocities(bodies: *Body, dt: f64, i: i64) -> i64 =
    if i >= N_BODIES() { 0 }
    else {
        let _inner = advance_velocities_inner(bodies, dt, i, i + 1);
        advance_velocities(bodies, dt, i + 1)
    };

// Advance positions
fn advance_positions(bodies: *Body, dt: f64, i: i64) -> i64 =
    if i >= N_BODIES() { 0 }
    else {
        let b = body_at(bodies, i);
        let _p1 = set b.x = b.x + dt * b.vx;
        let _p2 = set b.y = b.y + dt * b.vy;
        let _p3 = set b.z = b.z + dt * b.vz;
        advance_positions(bodies, dt, i + 1)
    };

// Advance simulation by dt
fn advance(bodies: *Body, dt: f64) -> i64 = {
    let _v = advance_velocities(bodies, dt, 0);
    advance_positions(bodies, dt, 0)
};

// Compute kinetic energy
fn kinetic_energy(bodies: *Body, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let b = body_at(bodies, i);
        let vx = b.vx;
        let vy = b.vy;
        let vz = b.vz;
        let m = b.mass;
        let ke = 0.5 * m * (vx * vx + vy * vy + vz * vz);
        kinetic_energy(bodies, i + 1, acc + ke)
    };

// Compute potential energy (inner loop)
fn potential_energy_inner(bodies: *Body, i: i64, j: i64, acc: f64) -> f64 =
    if j >= N_BODIES() { acc }
    else {
        let bi = body_at(bodies, i);
        let bj = body_at(bodies, j);
        let dx = bi.x - bj.x;
        let dy = bi.y - bj.y;
        let dz = bi.z - bj.z;
        let dist = sqrt(dx * dx + dy * dy + dz * dz);
        let pe = 0.0 - (bi.mass * bj.mass / dist);
        potential_energy_inner(bodies, i, j + 1, acc + pe)
    };

// Compute potential energy (outer loop)
fn potential_energy(bodies: *Body, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let pe = potential_energy_inner(bodies, i, i + 1, 0.0);
        potential_energy(bodies, i + 1, acc + pe)
    };

// Compute total energy
fn energy(bodies: *Body) -> f64 = {
    let ke = kinetic_energy(bodies, 0, 0.0);
    let pe = potential_energy(bodies, 0, 0.0);
    ke + pe
};

// Run simulation loop (using while for performance)
fn run_simulation(bodies: *Body, n: i64) -> i64 = {
    let mut step: i64 = 0;
    while step < n {
        { advance(bodies, 0.01) };
        { step = step + 1 };
    };
    0
};

fn main() -> i64 = {
    let bodies = bodies_new();
    let _init = init_bodies(bodies);
    let _offset = offset_momentum(bodies);

    // Print initial energy
    let e1 = energy(bodies);
    let e1_scaled = f64_to_i64(e1 * 1e9);
    let _p1 = println(e1_scaled);

    // Run simulation
    let _run = run_simulation(bodies, N_STEPS());

    // Print final energy
    let e2 = energy(bodies);
    let e2_scaled = f64_to_i64(e2 * 1e9);
    let _p2 = println(e2_scaled);

    let _f = free(bodies);  // v0.60.27: native pointer free
    0
};

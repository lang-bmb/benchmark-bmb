// N-Body simulation benchmark - FAIR VERSION
// v0.51.5: Rewritten to match C version exactly
// - 5 bodies (Sun, Jupiter, Saturn, Uranus, Neptune)
// - 500,000 steps
// Uses malloc-based arrays for body state

// Constants
fn PI() -> f64 = 3.141592653589793;
fn SOLAR_MASS() -> f64 = 4.0 * PI() * PI();
fn DAYS_PER_YEAR() -> f64 = 365.24;
fn N_BODIES() -> i64 = 5;
fn N_STEPS() -> i64 = 500000;

// Body structure (7 f64 values per body):
// offset 0: x, 8: y, 16: z, 24: vx, 32: vy, 40: vz, 48: mass
fn body_size() -> i64 = 56;  // 7 * 8 bytes

// Allocate bodies array
fn bodies_new() -> i64 = malloc(N_BODIES() * body_size());

// Body accessors
fn body_x(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 0);
fn body_y(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 8);
fn body_z(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 16);
fn body_vx(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 24);
fn body_vy(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 32);
fn body_vz(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 40);
fn body_mass(bodies: i64, i: i64) -> f64 = load_f64(bodies + i * body_size() + 48);

fn set_body_x(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 0, v); 0 };
fn set_body_y(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 8, v); 0 };
fn set_body_z(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 16, v); 0 };
fn set_body_vx(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 24, v); 0 };
fn set_body_vy(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 32, v); 0 };
fn set_body_vz(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 40, v); 0 };
fn set_body_mass(bodies: i64, i: i64, v: f64) -> i64 = { store_f64(bodies + i * body_size() + 48, v); 0 };

// Initialize all bodies
fn init_bodies(bodies: i64) -> i64 = {
    // Sun (at origin)
    let _s0 = set_body_x(bodies, 0, 0.0);
    let _s1 = set_body_y(bodies, 0, 0.0);
    let _s2 = set_body_z(bodies, 0, 0.0);
    let _s3 = set_body_vx(bodies, 0, 0.0);
    let _s4 = set_body_vy(bodies, 0, 0.0);
    let _s5 = set_body_vz(bodies, 0, 0.0);
    let _s6 = set_body_mass(bodies, 0, SOLAR_MASS());

    // Jupiter
    let _j0 = set_body_x(bodies, 1, 4.84143144246472090e0);
    let _j1 = set_body_y(bodies, 1, 0.0 - 1.16032004402742839e0);
    let _j2 = set_body_z(bodies, 1, 0.0 - 1.03622044471123109e-1);
    let _j3 = set_body_vx(bodies, 1, 1.66007664274403694e-3 * DAYS_PER_YEAR());
    let _j4 = set_body_vy(bodies, 1, 7.69901118419740425e-3 * DAYS_PER_YEAR());
    let _j5 = set_body_vz(bodies, 1, 0.0 - 6.90460016972063023e-5 * DAYS_PER_YEAR());
    let _j6 = set_body_mass(bodies, 1, 9.54791938424326609e-4 * SOLAR_MASS());

    // Saturn
    let _sa0 = set_body_x(bodies, 2, 8.34336671824457987e0);
    let _sa1 = set_body_y(bodies, 2, 4.12479856412430479e0);
    let _sa2 = set_body_z(bodies, 2, 0.0 - 4.03523417114321381e-1);
    let _sa3 = set_body_vx(bodies, 2, 0.0 - 2.76742510726862411e-3 * DAYS_PER_YEAR());
    let _sa4 = set_body_vy(bodies, 2, 4.99852801234917238e-3 * DAYS_PER_YEAR());
    let _sa5 = set_body_vz(bodies, 2, 2.30417297573763929e-5 * DAYS_PER_YEAR());
    let _sa6 = set_body_mass(bodies, 2, 2.85885980666130812e-4 * SOLAR_MASS());

    // Uranus
    let _u0 = set_body_x(bodies, 3, 1.28943695621391310e1);
    let _u1 = set_body_y(bodies, 3, 0.0 - 1.51111514016986312e1);
    let _u2 = set_body_z(bodies, 3, 0.0 - 2.23307578892655734e-1);
    let _u3 = set_body_vx(bodies, 3, 2.96460137564761618e-3 * DAYS_PER_YEAR());
    let _u4 = set_body_vy(bodies, 3, 2.37847173959480950e-3 * DAYS_PER_YEAR());
    let _u5 = set_body_vz(bodies, 3, 0.0 - 2.96589568540237556e-5 * DAYS_PER_YEAR());
    let _u6 = set_body_mass(bodies, 3, 4.36624404335156298e-5 * SOLAR_MASS());

    // Neptune
    let _n0 = set_body_x(bodies, 4, 1.53796971148509165e1);
    let _n1 = set_body_y(bodies, 4, 0.0 - 2.59193146099879641e1);
    let _n2 = set_body_z(bodies, 4, 1.79258772950371181e-1);
    let _n3 = set_body_vx(bodies, 4, 2.68067772490389322e-3 * DAYS_PER_YEAR());
    let _n4 = set_body_vy(bodies, 4, 1.62824170038242295e-3 * DAYS_PER_YEAR());
    let _n5 = set_body_vz(bodies, 4, 0.0 - 9.51592254519715870e-5 * DAYS_PER_YEAR());
    let _n6 = set_body_mass(bodies, 4, 5.15138902046611451e-5 * SOLAR_MASS());

    0
};

// Offset momentum (make total momentum zero)
fn offset_momentum(bodies: i64) -> i64 = {
    let px = compute_px(bodies, 0, 0.0);
    let py = compute_py(bodies, 0, 0.0);
    let pz = compute_pz(bodies, 0, 0.0);
    let _v1 = set_body_vx(bodies, 0, 0.0 - px / SOLAR_MASS());
    let _v2 = set_body_vy(bodies, 0, 0.0 - py / SOLAR_MASS());
    set_body_vz(bodies, 0, 0.0 - pz / SOLAR_MASS())
};

fn compute_px(bodies: i64, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else { compute_px(bodies, i + 1, acc + body_vx(bodies, i) * body_mass(bodies, i)) };

fn compute_py(bodies: i64, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else { compute_py(bodies, i + 1, acc + body_vy(bodies, i) * body_mass(bodies, i)) };

fn compute_pz(bodies: i64, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else { compute_pz(bodies, i + 1, acc + body_vz(bodies, i) * body_mass(bodies, i)) };

// Advance simulation by dt
fn advance(bodies: i64, dt: f64) -> i64 = {
    // Update velocities (pairwise interactions)
    let _v = advance_velocities(bodies, dt, 0);
    // Update positions
    advance_positions(bodies, dt, 0)
};

fn advance_velocities(bodies: i64, dt: f64, i: i64) -> i64 =
    if i >= N_BODIES() { 0 }
    else {
        let _inner = advance_velocities_inner(bodies, dt, i, i + 1);
        advance_velocities(bodies, dt, i + 1)
    };

fn advance_velocities_inner(bodies: i64, dt: f64, i: i64, j: i64) -> i64 =
    if j >= N_BODIES() { 0 }
    else {
        let dx = body_x(bodies, i) - body_x(bodies, j);
        let dy = body_y(bodies, i) - body_y(bodies, j);
        let dz = body_z(bodies, i) - body_z(bodies, j);
        let dist_sq = dx * dx + dy * dy + dz * dz;
        let dist = sqrt(dist_sq);
        let mag = dt / (dist_sq * dist);

        let mi = body_mass(bodies, i);
        let mj = body_mass(bodies, j);

        let _vi1 = set_body_vx(bodies, i, body_vx(bodies, i) - dx * mj * mag);
        let _vi2 = set_body_vy(bodies, i, body_vy(bodies, i) - dy * mj * mag);
        let _vi3 = set_body_vz(bodies, i, body_vz(bodies, i) - dz * mj * mag);

        let _vj1 = set_body_vx(bodies, j, body_vx(bodies, j) + dx * mi * mag);
        let _vj2 = set_body_vy(bodies, j, body_vy(bodies, j) + dy * mi * mag);
        let _vj3 = set_body_vz(bodies, j, body_vz(bodies, j) + dz * mi * mag);

        advance_velocities_inner(bodies, dt, i, j + 1)
    };

fn advance_positions(bodies: i64, dt: f64, i: i64) -> i64 =
    if i >= N_BODIES() { 0 }
    else {
        let _p1 = set_body_x(bodies, i, body_x(bodies, i) + dt * body_vx(bodies, i));
        let _p2 = set_body_y(bodies, i, body_y(bodies, i) + dt * body_vy(bodies, i));
        let _p3 = set_body_z(bodies, i, body_z(bodies, i) + dt * body_vz(bodies, i));
        advance_positions(bodies, dt, i + 1)
    };

// Compute total energy
fn energy(bodies: i64) -> f64 = {
    let ke = kinetic_energy(bodies, 0, 0.0);
    let pe = potential_energy(bodies, 0, 0.0);
    ke + pe
};

fn kinetic_energy(bodies: i64, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let vx = body_vx(bodies, i);
        let vy = body_vy(bodies, i);
        let vz = body_vz(bodies, i);
        let m = body_mass(bodies, i);
        let ke = 0.5 * m * (vx * vx + vy * vy + vz * vz);
        kinetic_energy(bodies, i + 1, acc + ke)
    };

fn potential_energy(bodies: i64, i: i64, acc: f64) -> f64 =
    if i >= N_BODIES() { acc }
    else {
        let pe = potential_energy_inner(bodies, i, i + 1, 0.0);
        potential_energy(bodies, i + 1, acc + pe)
    };

fn potential_energy_inner(bodies: i64, i: i64, j: i64, acc: f64) -> f64 =
    if j >= N_BODIES() { acc }
    else {
        let dx = body_x(bodies, i) - body_x(bodies, j);
        let dy = body_y(bodies, i) - body_y(bodies, j);
        let dz = body_z(bodies, i) - body_z(bodies, j);
        let dist = sqrt(dx * dx + dy * dy + dz * dz);
        let pe = 0.0 - (body_mass(bodies, i) * body_mass(bodies, j) / dist);
        potential_energy_inner(bodies, i, j + 1, acc + pe)
    };

// Run simulation loop (using while for performance)
fn run_simulation(bodies: i64, n: i64) -> i64 = {
    let mut step: i64 = 0;
    while step < n {
        advance(bodies, 0.01);
        step = step + 1;
    };
    0
};

fn main() -> i64 = {
    let bodies = bodies_new();
    let _init = init_bodies(bodies);
    let _offset = offset_momentum(bodies);

    // Print initial energy
    let e1 = energy(bodies);
    let e1_scaled = f64_to_i64(e1 * 1e9);
    let _p1 = println(e1_scaled);

    // Run simulation
    let _run = run_simulation(bodies, N_STEPS());

    // Print final energy
    let e2 = energy(bodies);
    let e2_scaled = f64_to_i64(e2 * 1e9);
    let _p2 = println(e2_scaled);

    let _f = free(bodies);
    0
};

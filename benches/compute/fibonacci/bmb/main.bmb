// Fibonacci - FAIR COMPARISON benchmark
// Uses iterative O(n) algorithm matching the C version exactly.
// For optimization demo (BMB O(2^n)->O(n) transformation), see main_optimization_demo.bmb
// Measures: loop iteration, integer arithmetic, accumulator pattern
// v0.69: @pure enables LLVM to constant-fold the loop

@pure
fn fibonacci_iter(n: i64) -> i64 = {
    let mut a: i64 = 0;
    let mut b: i64 = 1;
    let mut i: i64 = 0;
    while i < n {
        let temp = a + b;
        { a = b };
        { b = temp };
        { i = i + 1 }
    };
    a
};

fn main() -> i64 = {
    // Run fibonacci(50) 1000000000 times for stable measurement (target: ~120ms after LICM)
    // v0.60.52: Extreme LLVM optimization requires many iterations for stable timing
    let mut result: i64 = 0;
    let mut i: i64 = 0;
    while i < 1000000000 {
        let fib = fibonacci_iter(50);
        { result = result + fib };
        { i = i + 1 }
    };
    let _u = println(result);
    0
};

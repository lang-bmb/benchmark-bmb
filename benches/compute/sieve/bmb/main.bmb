// Sieve of Eratosthenes - Prime number benchmark v0.60.62
// v0.60.62: Use while loops instead of recursion for better performance

// Initialize array with 1s
fn init_array_loop(arr: i64, n: i64) -> i64 = {
    let mut i: i64 = 0;
    while i <= n {
        let _s = store_u8(arr + i, 1);
        { i = i + 1 }
    };
    0
};

// Mark multiples of p as composite
fn mark_multiples_loop(arr: i64, n: i64, p: i64) -> i64 = {
    let mut j: i64 = p * p;
    while j <= n {
        let _s = store_u8(arr + j, 0);
        { j = j + p }
    };
    0
};

// Main sieve loop
fn sieve_loop(arr: i64, n: i64) -> i64 = {
    let mut p: i64 = 2;
    while p * p <= n {
        let is_prime = load_u8(arr + p);
        let _mark = if is_prime == 1 { mark_multiples_loop(arr, n, p) } else { 0 };
        { p = p + 1 }
    };
    0
};

// Count primes
fn count_primes_loop(arr: i64, n: i64) -> i64 = {
    let mut count: i64 = 0;
    let mut k: i64 = 2;
    while k <= n {
        let is_prime = load_u8(arr + k);
        { count = count + is_prime as i64 };
        { k = k + 1 }
    };
    count
};

fn sieve(n: i64) -> i64 = {
    let arr = malloc(n + 1);
    let _init = init_array_loop(arr, n);
    let _m0 = store_u8(arr, 0);
    let _m1 = store_u8(arr + 1, 0);
    let _sieve = sieve_loop(arr, n);
    let count = count_primes_loop(arr, n);
    let _f = free(arr);
    count
};

fn main() -> i64 = {
    let mut result: i64 = 0;
    let mut iter: i64 = 0;
    while iter < 1500 {
        let c = sieve(100000);
        let _r = { result = result + c };
        { iter = iter + 1 }
    };
    let _p = println(result);
    0
};

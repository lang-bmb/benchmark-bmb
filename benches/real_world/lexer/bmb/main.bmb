// lexer - Token generation benchmark
// Tests character processing, state machine, keyword matching
// Self-contained with embedded source code

fn printline(s: String) -> i64 = { let u = println_str(s); 0 };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n % 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

// Token types (encoded as integers)
fn tok_eof() -> i64 = 0;
fn tok_ident() -> i64 = 1;
fn tok_number() -> i64 = 2;
fn tok_string() -> i64 = 3;
fn tok_keyword() -> i64 = 4;
fn tok_operator() -> i64 = 5;
fn tok_punct() -> i64 = 6;
fn tok_comment() -> i64 = 7;

// Character classification
fn is_whitespace(c: i64) -> i64 =
    if c == 32 or c == 9 or c == 10 or c == 13 { 1 } else { 0 };

fn is_alpha(c: i64) -> i64 =
    if (c >= 65 and c <= 90) or (c >= 97 and c <= 122) { 1 } else { 0 };

fn is_digit(c: i64) -> i64 =
    if c >= 48 and c <= 57 { 1 } else { 0 };

fn is_alnum(c: i64) -> i64 =
    if is_alpha(c) == 1 or is_digit(c) == 1 { 1 } else { 0 };

fn is_operator_char(c: i64) -> i64 =
    if c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
       c == 61 or c == 60 or c == 62 or c == 33 or c == 38 or c == 124 { 1 } else { 0 };

fn is_punct_char(c: i64) -> i64 =
    if c == 40 or c == 41 or c == 123 or c == 125 or c == 91 or c == 93 or
       c == 59 or c == 58 or c == 44 or c == 46 { 1 } else { 0 };

// Get byte at position (v0.51.44: use byte_at directly instead of ord(char_at()))
fn peek(src: String, pos: i64) -> i64 =
    if pos >= src.len() { 0 } else { src.byte_at(pos) };

// Skip whitespace
fn skip_ws(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if is_whitespace(peek(src, pos)) == 1 { skip_ws(src, pos + 1) }
    else { pos };

// Check for keyword (simplified: just check length and first char)
fn is_keyword_at(src: String, start: i64, len: i64) -> i64 =
    if len == 2 and peek(src, start) == 102 and peek(src, start + 1) == 110 { 1 }      -- fn
    else if len == 3 and peek(src, start) == 108 and peek(src, start + 1) == 101 { 1 } -- let
    else if len == 2 and peek(src, start) == 105 and peek(src, start + 1) == 102 { 1 } -- if
    else if len == 4 and peek(src, start) == 101 { 1 }  -- else
    else if len == 5 and peek(src, start) == 119 { 1 }  -- while
    else if len == 6 and peek(src, start) == 114 { 1 }  -- return
    else if len == 4 and peek(src, start) == 116 { 1 }  -- true
    else if len == 5 and peek(src, start) == 102 { 1 }  -- false
    else { 0 };

// Skip identifier
fn skip_ident(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if is_alnum(peek(src, pos)) == 1 or peek(src, pos) == 95 { skip_ident(src, pos + 1) }
    else { pos };

// Skip number
fn skip_number(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if is_digit(peek(src, pos)) == 1 or peek(src, pos) == 46 { skip_number(src, pos + 1) }
    else { pos };

// Skip string
fn skip_string(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if peek(src, pos) == 34 { pos + 1 }  -- closing quote
    else if peek(src, pos) == 92 { skip_string(src, pos + 2) }  -- escape
    else { skip_string(src, pos + 1) };

// Skip comment to end of line
fn skip_comment(src: String, pos: i64) -> i64 =
    if pos >= src.len() { pos }
    else if peek(src, pos) == 10 { pos }
    else { skip_comment(src, pos + 1) };

// Get next token - returns (token_type, new_pos) tuple
fn next_token(src: String, pos: i64) -> (i64, i64) = {
    let p = skip_ws(src, pos);
    if p >= src.len() { (tok_eof(), p) }
    else {
        let c = peek(src, p);
        -- Comment
        if c == 45 and peek(src, p + 1) == 45 {
            let end = skip_comment(src, p + 2);
            (tok_comment(), end)
        }
        -- Identifier or keyword
        else if is_alpha(c) == 1 or c == 95 {
            let end = skip_ident(src, p + 1);
            let len = end - p;
            let tok = if is_keyword_at(src, p, len) == 1 { tok_keyword() } else { tok_ident() };
            (tok, end)
        }
        -- Number
        else if is_digit(c) == 1 {
            let end = skip_number(src, p + 1);
            (tok_number(), end)
        }
        -- String
        else if c == 34 {
            let end = skip_string(src, p + 1);
            (tok_string(), end)
        }
        -- Operator (check 2-char first)
        else if is_operator_char(c) == 1 {
            let c2 = peek(src, p + 1);
            if (c == 61 or c == 33 or c == 60 or c == 62) and c2 == 61 {
                (tok_operator(), p + 2)
            }
            else if (c == 38 and c2 == 38) or (c == 124 and c2 == 124) {
                (tok_operator(), p + 2)
            }
            else {
                (tok_operator(), p + 1)
            }
        }
        -- Punctuation
        else if is_punct_char(c) == 1 {
            (tok_punct(), p + 1)
        }
        else {
            (tok_eof(), p)
        }
    }
};

// Count tokens loop - uses native tuples
fn count_tokens_loop(src: String, pos: i64, ident: i64, num: i64, str: i64, kw: i64, op: i64, punct: i64, comment: i64) -> i64 = {
    let result = next_token(src, pos);
    let tok = result.0;
    let new_pos = result.1;
    if tok == tok_eof() {
        ident * 10000000 + num * 100000 + kw * 1000 + op * 10 + punct
    }
    else {
        let new_ident = if tok == tok_ident() { ident + 1 } else { ident };
        let new_num = if tok == tok_number() { num + 1 } else { num };
        let new_kw = if tok == tok_keyword() { kw + 1 } else { kw };
        let new_op = if tok == tok_operator() { op + 1 } else { op };
        let new_punct = if tok == tok_punct() { punct + 1 } else { punct };
        count_tokens_loop(src, new_pos, new_ident, new_num, str, new_kw, new_op, new_punct, comment)
    }
};

fn count_tokens(src: String) -> i64 =
    count_tokens_loop(src, 0, 0, 0, 0, 0, 0, 0, 0);

// Test source code (v0.55: FAIR - matches C version exactly)
fn test_source() -> String =
    "fn fibonacci(n: i64) -> i64 =\n" +
    "    if n <= 1 { n }\n" +
    "    else { fibonacci(n - 1) + fibonacci(n - 2) };\n" +
    "\n" +
    "fn main() -> i64 = {\n" +
    "    let result = fibonacci(35);\n" +
    "    -- This is a comment\n" +
    "    let x = 42;\n" +
    "    let y = 3.14159;\n" +
    "    let s = " + chr(34) + "Hello, World!" + chr(34) + ";\n" +
    "    if x > 10 && y < 100.0 {\n" +
    "        return result;\n" +
    "    } else {\n" +
    "        return 0;\n" +
    "    }\n" +
    "};\n";

// Generate larger source using StringBuilder (O(n) instead of O(nÂ²))
fn gen_large(n: i64) -> String = {
    let sb = sb_new();
    let src = test_source();
    let mut i: i64 = 0;
    while i < n { {
        sb_push(sb, src);
        i = i + 1;
        ()
    } };
    sb_build(sb)
};

fn main() -> i64 = {
    let u1 = printline("Lexer Benchmark");

    -- Test small source
    let src = test_source();
    let counts = count_tokens(src);

    let ident = counts / 10000000;
    let num = (counts / 100000) % 100;
    let kw = (counts / 1000) % 100;
    let op = (counts / 10) % 100;
    let punct = counts % 10;

    let u2 = printline("Small source:");
    let u3 = printline("  Identifiers: " + int_to_string(ident));
    let u4 = printline("  Numbers: " + int_to_string(num));
    let u5 = printline("  Keywords: " + int_to_string(kw));
    let u6 = printline("  Operators: " + int_to_string(op));
    let u7 = printline("  Punctuation: " + int_to_string(punct));
    let u8 = printline("");

    -- Larger source (100x - encoding limits prevent higher iterations)
    let large = gen_large(100);
    let large_counts = count_tokens(large);
    let total = (large_counts / 10000000) + ((large_counts / 100000) % 100) +
                ((large_counts / 1000) % 100) + ((large_counts / 10) % 100) + (large_counts % 10);

    let u9 = printline("Large source (100x):");
    let u10 = printline("  Total tokens: " + int_to_string(total));

    printline("Done.")
};

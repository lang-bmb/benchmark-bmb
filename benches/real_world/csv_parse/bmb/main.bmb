// csv-parse - CSV parsing benchmark
// Tests string processing, field extraction
// v0.51.50: Single-pass parsing for optimal performance

fn printline(s: String) -> i64 = { let _u = println_str(s); 0 };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) }
    else if n < 10 { digit_char(n) }
    else { int_to_string(n / 10) + digit_char(n % 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" }
    else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" }
    else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" }
    else { "9" };

// Single-pass parsing: count rows, commas, and quotes in one iteration
// Returns: rows * 10000000 + fields * 10000 + quoted
fn parse_single_pass(data: String) -> i64 = {
    let data_len = data.len();
    let mut pos: i64 = 0;
    let mut rows: i64 = 0;
    let mut commas: i64 = 0;
    let mut quotes: i64 = 0;
    let mut c: i64 = 0;
    let mut in_row: i64 = 0;  -- 1 if we've seen non-separator content

    while pos < data_len { {
        c = data.byte_at(pos);
        -- Count character types
        commas = if c == 44 { commas + 1 } else { commas };   -- comma
        quotes = if c == 34 { quotes + 1 } else { quotes };   -- quote
        -- Track rows (newline or pipe ends a row)
        rows = if c == 10 { rows + 1 }                        -- newline
               else { if c == 124 { rows + 1 }                -- pipe
               else { rows } };
        pos = pos + 1;
        ()
    } };

    -- Add final row if data doesn't end with separator
    rows = if data_len > 0 { rows + 1 } else { rows };
    -- Fields = commas + rows (each row has commas+1 fields)
    -- Quoted fields = quotes / 2
    rows * 10000000 + (commas + rows) * 10000 + (quotes / 2)
};

fn get_stat_rows(stats: i64) -> i64 = stats / 10000000;
fn get_stat_fields(stats: i64) -> i64 = (stats / 10000) % 1000;
fn get_stat_quoted(stats: i64) -> i64 = stats % 10000;

fn print_stats(stats: i64) -> i64 = {
    let _u1 = printline("  Rows: " + int_to_string(get_stat_rows(stats)));
    let _u2 = printline("  Fields: " + int_to_string(get_stat_fields(stats)));
    printline("  Quoted fields: " + int_to_string(get_stat_quoted(stats)))
};

fn quote() -> String = chr(34);

fn test_data() -> String =
    "name,age,city,salary|John Doe,30,New York,50000|Jane Smith,25,Los Angeles,60000|" +
    quote() + "Bob Jones" + quote() + ",45,Chicago,75000|Alice,28," + quote() + "San Francisco" + quote() + ",80000|Charlie,35,Boston,55000";

fn generate_row() -> String =
    "field1,field2,field3," + quote() + "quoted" + quote() + ",field5|";

fn generate_large(n: i64) -> String = {
    let sb = sb_new();
    let row = generate_row();
    let mut i: i64 = 0;
    while i < n { {
        sb_push(sb, row);
        i = i + 1;
        ()
    } };
    sb_build(sb)
};

fn main() -> i64 = {
    let _u1 = printline("CSV Parse Benchmark");
    let _u2 = printline("");

    let data = test_data();
    let stats = parse_single_pass(data);
    let _u3 = printline("Small dataset:");
    let _u4 = print_stats(stats);
    let _u5 = printline("");

    let large = generate_large(1000);
    let large_stats = parse_single_pass(large);
    let _u6 = printline("Large dataset (1000 rows):");
    let _u7 = print_stats(large_stats);

    let _u8 = printline("");
    printline("Done.")
};

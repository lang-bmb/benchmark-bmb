// Sorting benchmark - FAIR VERSION
// Measures: comparison operations, data movement
// Uses actual array sorting like C version
// v0.51.5: Rewritten to match C workload exactly

// Array operations using malloc/load_i64/store_i64
fn array_new(n: i64) -> i64 = malloc(n * 8);
fn array_get(arr: i64, i: i64) -> i64 = load_i64(arr + i * 8);
fn array_set(arr: i64, i: i64, val: i64) -> i64 = { store_i64(arr + i * 8, val); 0 };
fn array_free(arr: i64) -> i64 = { free(arr); 0 };

// Swap two elements in array
fn swap(arr: i64, i: i64, j: i64) -> i64 = {
    let tmp = array_get(arr, i);
    let _a = array_set(arr, i, array_get(arr, j));
    array_set(arr, j, tmp)
};

// Initialize array with reverse order (worst case for bubble/insertion sort)
fn init_reverse(arr: i64, size: i64) -> i64 =
    init_reverse_loop(arr, size, 0);

fn init_reverse_loop(arr: i64, size: i64, i: i64) -> i64 =
    if i >= size { 0 }
    else {
        let _s = array_set(arr, i, size - i);
        init_reverse_loop(arr, size, i + 1)
    };

// ============ Bubble Sort ============
fn bubble_sort(arr: i64, n: i64) -> i64 =
    bubble_outer(arr, n, 0, 0);

fn bubble_outer(arr: i64, n: i64, i: i64, comparisons: i64) -> i64 =
    if i >= n - 1 { comparisons }
    else {
        let new_comparisons = bubble_inner(arr, n, i, 0, comparisons);
        bubble_outer(arr, n, i + 1, new_comparisons)
    };

fn bubble_inner(arr: i64, n: i64, i: i64, j: i64, comparisons: i64) -> i64 =
    if j >= n - i - 1 { comparisons }
    else {
        let a = array_get(arr, j);
        let b = array_get(arr, j + 1);
        let _s = if a > b { swap(arr, j, j + 1) } else { 0 };
        bubble_inner(arr, n, i, j + 1, comparisons + 1)
    };

// ============ Insertion Sort ============
fn insertion_sort(arr: i64, n: i64) -> i64 =
    insertion_outer(arr, n, 1, 0);

fn insertion_outer(arr: i64, n: i64, i: i64, cost: i64) -> i64 =
    if i >= n { cost }
    else {
        let key = array_get(arr, i);
        let result = insertion_inner(arr, i - 1, key, cost);
        insertion_outer(arr, n, i + 1, result)
    };

fn insertion_inner(arr: i64, j: i64, key: i64, cost: i64) -> i64 =
    if j < 0 {
        let _s = array_set(arr, j + 1, key);
        cost + 1
    }
    else if array_get(arr, j) > key {
        let _s = array_set(arr, j + 1, array_get(arr, j));
        insertion_inner(arr, j - 1, key, cost + 1)
    }
    else {
        let _s = array_set(arr, j + 1, key);
        cost + 1
    };

// ============ Merge Sort ============
// Returns cost (comparison count)
fn merge_sort(arr: i64, n: i64) -> i64 =
    merge_sort_helper(arr, 0, n - 1);

fn merge_sort_helper(arr: i64, l: i64, r: i64) -> i64 =
    if l < r {
        let m = l + (r - l) / 2;
        let cost_left = merge_sort_helper(arr, l, m);
        let cost_right = merge_sort_helper(arr, m + 1, r);
        let cost_merge = merge(arr, l, m, r);
        cost_left + cost_right + cost_merge
    } else { 0 };

fn merge(arr: i64, l: i64, m: i64, r: i64) -> i64 = {
    let n1 = m - l + 1;
    let n2 = r - m;
    let left_arr = array_new(n1);
    let right_arr = array_new(n2);

    // Copy data to temp arrays
    let _c1 = copy_to_temp(arr, left_arr, l, n1, 0);
    let _c2 = copy_to_temp(arr, right_arr, m + 1, n2, 0);

    // Merge temp arrays back
    let cost = merge_arrays(arr, left_arr, right_arr, n1, n2, l, 0, 0, 0);

    let _f1 = array_free(left_arr);
    let _f2 = array_free(right_arr);
    cost
};

fn copy_to_temp(src: i64, dst: i64, src_start: i64, count: i64, i: i64) -> i64 =
    if i >= count { 0 }
    else {
        let _s = array_set(dst, i, array_get(src, src_start + i));
        copy_to_temp(src, dst, src_start, count, i + 1)
    };

fn merge_arrays(arr: i64, left: i64, right: i64, n1: i64, n2: i64, k: i64, i: i64, j: i64, cost: i64) -> i64 =
    if i >= n1 and j >= n2 { cost }
    else if i >= n1 {
        // Copy remaining right
        let _c = copy_remaining(arr, right, k, j, n2);
        cost
    }
    else if j >= n2 {
        // Copy remaining left
        let _c = copy_remaining(arr, left, k, i, n1);
        cost
    }
    else {
        let l_val = array_get(left, i);
        let r_val = array_get(right, j);
        if l_val <= r_val {
            let _s = array_set(arr, k, l_val);
            merge_arrays(arr, left, right, n1, n2, k + 1, i + 1, j, cost + 1)
        } else {
            let _s = array_set(arr, k, r_val);
            merge_arrays(arr, left, right, n1, n2, k + 1, i, j + 1, cost + 1)
        }
    };

fn copy_remaining(arr: i64, src: i64, k: i64, i: i64, n: i64) -> i64 =
    if i >= n { 0 }
    else {
        let _s = array_set(arr, k, array_get(src, i));
        copy_remaining(arr, src, k + 1, i + 1, n)
    };

// ============ Quick Sort ============
// Returns cost (comparison count)
fn quick_sort(arr: i64, n: i64) -> i64 =
    quick_sort_helper(arr, 0, n - 1);

fn quick_sort_helper(arr: i64, low: i64, high: i64) -> i64 =
    if low < high {
        // partition returns: pi * 1000000 + cost
        let result = partition(arr, low, high);
        let pi = result / 1000000;
        let partition_cost = result % 1000000;
        let cost_left = quick_sort_helper(arr, low, pi - 1);
        let cost_right = quick_sort_helper(arr, pi + 1, high);
        partition_cost + cost_left + cost_right
    } else { 0 };

// Returns: pi * 1000000 + cost (encoded)
fn partition(arr: i64, low: i64, high: i64) -> i64 = {
    let pivot = array_get(arr, high);
    partition_loop(arr, low, high, pivot, low, low - 1, 0)
};

fn partition_loop(arr: i64, low: i64, high: i64, pivot: i64, j: i64, i: i64, cost: i64) -> i64 =
    if j >= high {
        let _s = swap(arr, i + 1, high);
        (i + 1) * 1000000 + cost  // Return encoded pi and cost
    }
    else {
        if array_get(arr, j) <= pivot {
            let new_i = i + 1;
            let _s = swap(arr, new_i, j);
            partition_loop(arr, low, high, pivot, j + 1, new_i, cost + 1)
        }
        else {
            partition_loop(arr, low, high, pivot, j + 1, i, cost + 1)
        }
    };

// ============ Main Benchmark ============
// Matches C version: sizes from 50 down to 1, each size * 10
fn run_benchmark(sizes: i64, acc: i64) -> i64 =
    if sizes <= 0 { acc }
    else {
        let size = sizes * 10;
        let arr = array_new(size);

        // Bubble sort
        let _i1 = init_reverse(arr, size);
        let bubble = bubble_sort(arr, size);

        // Insertion sort
        let _i2 = init_reverse(arr, size);
        let insertion = insertion_sort(arr, size);

        // Merge sort
        let _i3 = init_reverse(arr, size);
        let merge_cost = merge_sort(arr, size);

        // Quick sort
        let _i4 = init_reverse(arr, size);
        let quick = quick_sort(arr, size);

        let _f = array_free(arr);
        run_benchmark(sizes - 1, acc + bubble + insertion + merge_cost + quick)
    };

fn main() -> i64 = {
    let result = run_benchmark(50, 0);
    let _u = println(result);
    0
};

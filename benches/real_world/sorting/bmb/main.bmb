// Sorting benchmark - FAIR VERSION v0.56
// Measures: comparison operations, data movement
// v0.56: Inlined array accessors for reduced overhead

// Inlined array operations
fn array_new(n: i64) -> i64 = malloc(n * 8);
fn array_free(arr: i64) -> i64 = { let _u = free(arr); 0 };

// Swap two elements in array (inlined)
fn swap(arr: i64, i: i64, j: i64) -> i64 = {
    let tmp = load_i64(arr + i * 8);
    let _a = store_i64(arr + i * 8, load_i64(arr + j * 8));
    let _b = store_i64(arr + j * 8, tmp);
    0
};

// Initialize array with reverse order (worst case for bubble/insertion sort)
fn init_reverse(arr: i64, size: i64) -> i64 =
    init_reverse_loop(arr, size, 0);

fn init_reverse_loop(arr: i64, size: i64, i: i64) -> i64 =
    if i >= size { 0 }
    else {
        let _s = store_i64(arr + i * 8, size - i);
        init_reverse_loop(arr, size, i + 1)
    };

// ============ Bubble Sort (inlined array access) ============
fn bubble_sort(arr: i64, n: i64) -> i64 =
    bubble_outer(arr, n, 0, 0);

fn bubble_outer(arr: i64, n: i64, i: i64, comparisons: i64) -> i64 =
    if i >= n - 1 { comparisons }
    else {
        let new_comparisons = bubble_inner(arr, n, i, 0, comparisons);
        bubble_outer(arr, n, i + 1, new_comparisons)
    };

fn bubble_inner(arr: i64, n: i64, i: i64, j: i64, comparisons: i64) -> i64 =
    if j >= n - i - 1 { comparisons }
    else {
        let a = load_i64(arr + j * 8);
        let b = load_i64(arr + (j + 1) * 8);
        let _s = if a > b { swap(arr, j, j + 1) } else { 0 };
        bubble_inner(arr, n, i, j + 1, comparisons + 1)
    };

// ============ Insertion Sort (inlined array access) ============
fn insertion_sort(arr: i64, n: i64) -> i64 =
    insertion_outer(arr, n, 1, 0);

fn insertion_outer(arr: i64, n: i64, i: i64, cost: i64) -> i64 =
    if i >= n { cost }
    else {
        let key = load_i64(arr + i * 8);
        let result = insertion_inner(arr, i - 1, key, cost);
        insertion_outer(arr, n, i + 1, result)
    };

fn insertion_inner(arr: i64, j: i64, key: i64, cost: i64) -> i64 =
    if j < 0 {
        let _s = store_i64(arr + (j + 1) * 8, key);
        cost + 1
    }
    else if load_i64(arr + j * 8) > key {
        let _s = store_i64(arr + (j + 1) * 8, load_i64(arr + j * 8));
        insertion_inner(arr, j - 1, key, cost + 1)
    }
    else {
        let _s = store_i64(arr + (j + 1) * 8, key);
        cost + 1
    };

// ============ Merge Sort (inlined array access) ============
fn merge_sort(arr: i64, n: i64) -> i64 =
    merge_sort_helper(arr, 0, n - 1);

fn merge_sort_helper(arr: i64, l: i64, r: i64) -> i64 =
    if l < r {
        let m = l + (r - l) / 2;
        let cost_left = merge_sort_helper(arr, l, m);
        let cost_right = merge_sort_helper(arr, m + 1, r);
        let cost_merge = merge(arr, l, m, r);
        cost_left + cost_right + cost_merge
    } else { 0 };

fn merge(arr: i64, l: i64, m: i64, r: i64) -> i64 = {
    let n1 = m - l + 1;
    let n2 = r - m;
    let left_arr = array_new(n1);
    let right_arr = array_new(n2);

    // Copy data to temp arrays
    let _c1 = copy_to_temp(arr, left_arr, l, n1, 0);
    let _c2 = copy_to_temp(arr, right_arr, m + 1, n2, 0);

    // Merge temp arrays back
    let cost = merge_arrays(arr, left_arr, right_arr, n1, n2, l, 0, 0, 0);

    let _f1 = array_free(left_arr);
    let _f2 = array_free(right_arr);
    cost
};

fn copy_to_temp(src: i64, dst: i64, src_start: i64, count: i64, i: i64) -> i64 =
    if i >= count { 0 }
    else {
        let _s = store_i64(dst + i * 8, load_i64(src + (src_start + i) * 8));
        copy_to_temp(src, dst, src_start, count, i + 1)
    };

fn merge_arrays(arr: i64, left: i64, right: i64, n1: i64, n2: i64, k: i64, i: i64, j: i64, cost: i64) -> i64 =
    if i >= n1 and j >= n2 { cost }
    else if i >= n1 {
        let _c = copy_remaining(arr, right, k, j, n2);
        cost
    }
    else if j >= n2 {
        let _c = copy_remaining(arr, left, k, i, n1);
        cost
    }
    else {
        let l_val = load_i64(left + i * 8);
        let r_val = load_i64(right + j * 8);
        if l_val <= r_val {
            let _s = store_i64(arr + k * 8, l_val);
            merge_arrays(arr, left, right, n1, n2, k + 1, i + 1, j, cost + 1)
        } else {
            let _s = store_i64(arr + k * 8, r_val);
            merge_arrays(arr, left, right, n1, n2, k + 1, i, j + 1, cost + 1)
        }
    };

fn copy_remaining(arr: i64, src: i64, k: i64, i: i64, n: i64) -> i64 =
    if i >= n { 0 }
    else {
        let _s = store_i64(arr + k * 8, load_i64(src + i * 8));
        copy_remaining(arr, src, k + 1, i + 1, n)
    };

// ============ Quick Sort (inlined array access) ============
fn quick_sort(arr: i64, n: i64) -> i64 =
    quick_sort_helper(arr, 0, n - 1);

fn quick_sort_helper(arr: i64, low: i64, high: i64) -> i64 =
    if low < high {
        let result = partition(arr, low, high);
        let pi = result.0;
        let partition_cost = result.1;
        let cost_left = quick_sort_helper(arr, low, pi - 1);
        let cost_right = quick_sort_helper(arr, pi + 1, high);
        partition_cost + cost_left + cost_right
    } else { 0 };

// Returns (pivot_index, comparison_cost)
fn partition(arr: i64, low: i64, high: i64) -> (i64, i64) = {
    let pivot = load_i64(arr + high * 8);
    partition_loop(arr, low, high, pivot, low, low - 1, 0)
};

fn partition_loop(arr: i64, low: i64, high: i64, pivot: i64, j: i64, i: i64, cost: i64) -> (i64, i64) =
    if j >= high {
        let _s = swap(arr, i + 1, high);
        (i + 1, cost)
    }
    else {
        if load_i64(arr + j * 8) <= pivot {
            let new_i = i + 1;
            let _s = swap(arr, new_i, j);
            partition_loop(arr, low, high, pivot, j + 1, new_i, cost + 1)
        }
        else {
            partition_loop(arr, low, high, pivot, j + 1, i, cost + 1)
        }
    };

// ============ Main Benchmark ============
fn run_benchmark(sizes: i64, acc: i64) -> i64 =
    if sizes <= 0 { acc }
    else {
        let size = sizes * 10;
        let arr = array_new(size);

        // Bubble sort
        let _i1 = init_reverse(arr, size);
        let bubble = bubble_sort(arr, size);

        // Insertion sort
        let _i2 = init_reverse(arr, size);
        let insertion = insertion_sort(arr, size);

        // Merge sort
        let _i3 = init_reverse(arr, size);
        let merge_cost = merge_sort(arr, size);

        // Quick sort
        let _i4 = init_reverse(arr, size);
        let quick = quick_sort(arr, size);

        let _f = array_free(arr);
        run_benchmark(sizes - 1, acc + bubble + insertion + merge_cost + quick)
    };

fn main() -> i64 = {
    // v0.60: Increased from 50 to 200 for better measurement accuracy (~28ms)
    let result = run_benchmark(200, 0);
    let _u = println(result);
    0
};

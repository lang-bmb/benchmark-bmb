// Sorting benchmark - FAIR VERSION v0.60.249
// Measures: comparison operations, data movement
// v0.60.249: Converted to native while loops for C-equivalent performance
// v0.60.246: Optimized with @inline on all hot paths
// v0.60.123: Add @inline to hot inner loops to prevent narrowing overhead
// v0.56: Inlined array accessors for reduced overhead

// Inlined array operations
@inline
fn array_new(n: i64) -> i64 = malloc(n * 8);
@inline
fn array_free(arr: i64) -> i64 = { let _u = free(arr); 0 };

// Swap two elements in array (inlined)
@inline
fn swap(arr: i64, i: i64, j: i64) -> i64 = {
    let tmp = load_i64(arr + i * 8);
    let _a = store_i64(arr + i * 8, load_i64(arr + j * 8));
    let _b = store_i64(arr + j * 8, tmp);
    0
};

// Initialize array with reverse order (worst case for bubble/insertion sort)
fn init_reverse(arr: i64, size: i64) -> i64 = {
    let mut i = 0;
    while i < size {
        let _s = store_i64(arr + i * 8, size - i);
        { i = i + 1; 0 }
    };
    0
};

// ============ Bubble Sort (while loop version) ============
fn bubble_sort(arr: i64, n: i64) -> i64 = {
    let mut comparisons = 0;
    let mut i = 0;
    while i < n - 1 {
        let mut j = 0;
        let limit = n - i - 1;
        while j < limit {
            let a = load_i64(arr + j * 8);
            let b = load_i64(arr + (j + 1) * 8);
            let _s = if a > b { swap(arr, j, j + 1) } else { 0 };
            { comparisons = comparisons + 1; j = j + 1; 0 }
        };
        { i = i + 1; 0 }
    };
    comparisons
};

// ============ Insertion Sort (while loop version) ============
fn insertion_sort(arr: i64, n: i64) -> i64 = {
    let mut cost = 0;
    let mut i = 1;
    while i < n {
        let key = load_i64(arr + i * 8);
        let mut j = i - 1;
        while j >= 0 and load_i64(arr + j * 8) > key {
            let _s = store_i64(arr + (j + 1) * 8, load_i64(arr + j * 8));
            { cost = cost + 1; j = j - 1; 0 }
        };
        let _s = store_i64(arr + (j + 1) * 8, key);
        { cost = cost + 1; i = i + 1; 0 }
    };
    cost
};

// ============ Merge Sort (while loop version) ============
fn merge_sort(arr: i64, n: i64) -> i64 =
    merge_sort_helper(arr, 0, n - 1);

fn merge_sort_helper(arr: i64, l: i64, r: i64) -> i64 =
    if l < r {
        let m = l + (r - l) / 2;
        let cost_left = merge_sort_helper(arr, l, m);
        let cost_right = merge_sort_helper(arr, m + 1, r);
        let cost_merge = merge(arr, l, m, r);
        cost_left + cost_right + cost_merge
    } else { 0 };

fn merge(arr: i64, l: i64, m: i64, r: i64) -> i64 = {
    let n1 = m - l + 1;
    let n2 = r - m;
    let left_arr = array_new(n1);
    let right_arr = array_new(n2);

    // Copy data to temp arrays (while loop)
    let mut ci = 0;
    while ci < n1 {
        let _s = store_i64(left_arr + ci * 8, load_i64(arr + (l + ci) * 8));
        { ci = ci + 1; 0 }
    };
    { ci = 0; 0 };
    while ci < n2 {
        let _s = store_i64(right_arr + ci * 8, load_i64(arr + (m + 1 + ci) * 8));
        { ci = ci + 1; 0 }
    };

    // Merge temp arrays back (while loop)
    let mut i = 0;
    let mut j = 0;
    let mut k = l;
    let mut cost = 0;

    while i < n1 and j < n2 {
        let l_val = load_i64(left_arr + i * 8);
        let r_val = load_i64(right_arr + j * 8);
        let _s = if l_val <= r_val {
            let _st = store_i64(arr + k * 8, l_val);
            { i = i + 1; 0 }
        } else {
            let _st = store_i64(arr + k * 8, r_val);
            { j = j + 1; 0 }
        };
        { cost = cost + 1; k = k + 1; 0 }
    };

    // Copy remaining elements
    while i < n1 {
        let _s = store_i64(arr + k * 8, load_i64(left_arr + i * 8));
        { i = i + 1; k = k + 1; 0 }
    };
    while j < n2 {
        let _s = store_i64(arr + k * 8, load_i64(right_arr + j * 8));
        { j = j + 1; k = k + 1; 0 }
    };

    let _f1 = array_free(left_arr);
    let _f2 = array_free(right_arr);
    cost
};

// ============ Quick Sort (while loop version) ============
fn quick_sort(arr: i64, n: i64) -> i64 =
    quick_sort_helper(arr, 0, n - 1);

fn quick_sort_helper(arr: i64, low: i64, high: i64) -> i64 =
    if low < high {
        let result = partition(arr, low, high);
        let pi = result.0;
        let partition_cost = result.1;
        let cost_left = quick_sort_helper(arr, low, pi - 1);
        let cost_right = quick_sort_helper(arr, pi + 1, high);
        partition_cost + cost_left + cost_right
    } else { 0 };

// Returns (pivot_index, comparison_cost)
fn partition(arr: i64, low: i64, high: i64) -> (i64, i64) = {
    let pivot = load_i64(arr + high * 8);
    let mut i = low - 1;
    let mut j = low;
    let mut cost = 0;

    while j < high {
        let _s = if load_i64(arr + j * 8) <= pivot {
            { i = i + 1; swap(arr, i, j) }
        } else { 0 };
        { cost = cost + 1; j = j + 1; 0 }
    };

    let _s = swap(arr, i + 1, high);
    (i + 1, cost)
};

// ============ Main Benchmark ============
fn run_benchmark(sizes: i64, acc: i64) -> i64 =
    if sizes <= 0 { acc }
    else {
        let size = sizes * 10;
        let arr = array_new(size);

        // Bubble sort
        let _i1 = init_reverse(arr, size);
        let bubble = bubble_sort(arr, size);

        // Insertion sort
        let _i2 = init_reverse(arr, size);
        let insertion = insertion_sort(arr, size);

        // Merge sort
        let _i3 = init_reverse(arr, size);
        let merge_cost = merge_sort(arr, size);

        // Quick sort
        let _i4 = init_reverse(arr, size);
        let quick = quick_sort(arr, size);

        let _f = array_free(arr);
        run_benchmark(sizes - 1, acc + bubble + insertion + merge_cost + quick)
    };

fn main() -> i64 = {
    // v0.60: Increased from 50 to 200 for better measurement accuracy (~28ms)
    let result = run_benchmark(200, 0);
    let _u = println(result);
    0
};

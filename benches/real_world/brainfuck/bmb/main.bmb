// brainfuck - Esoteric language interpreter benchmark
// Tests interpreter overhead, loop handling, array access
// v0.55: Fixed to use 1-byte cells (like C) instead of 8-byte cells
// Performance target: C parity

fn printline(s: String) -> i64 = { let _u = println_str(s); 0 };

// Tape size (same as C version)
fn tape_size() -> i64 = 30000;

// Array operations using malloc for direct memory access (1 byte per cell, like C)
fn tape_new() -> i64 = calloc(tape_size(), 1);  -- zero-initialized u8 array
fn tape_free(tape: i64) -> i64 = { free(tape); 0 };
fn tape_get(tape: i64, ptr: i64) -> i64 = load_u8(tape + ptr);
fn tape_set(tape: i64, ptr: i64, val: i64) -> i64 = { store_u8(tape + ptr, val); 0 };

// Get byte at position in program string
fn get_char(prog: String, pos: i64) -> i64 =
    if pos >= prog.len() { 0 }
    else { prog.byte_at(pos) };

// Find matching bracket using while loop
fn find_matching_close(prog: String, start_pc: i64) -> i64 = {
    let mut pc: i64 = start_pc + 1;
    let mut depth: i64 = 1;
    let mut c: i64 = 0;

    while depth > 0 { {
        c = get_char(prog, pc);
        depth = if c == 91 { depth + 1 } else { if c == 93 { depth - 1 } else { depth } };
        pc = pc + 1;
        ()
    } };
    pc - 1
};

fn find_matching_open(prog: String, start_pc: i64) -> i64 = {
    let mut pc: i64 = start_pc - 1;
    let mut depth: i64 = 1;
    let mut c: i64 = 0;

    while depth > 0 { {
        c = get_char(prog, pc);
        depth = if c == 93 { depth + 1 } else { if c == 91 { depth - 1 } else { depth } };
        pc = pc - 1;
        ()
    } };
    pc + 1
};

// Individual instruction handlers
fn do_right(ptr: i64, ts: i64) -> i64 = if ptr + 1 >= ts { 0 } else { ptr + 1 };
fn do_left(ptr: i64, ts: i64) -> i64 = if ptr == 0 { ts - 1 } else { ptr - 1 };
fn do_inc(val: i64) -> i64 = (val + 1) % 256;
fn do_dec(val: i64) -> i64 = if val == 0 { 255 } else { val - 1 };

// Execute single instruction, returns (new_ptr, new_pc) tuple
fn exec_instr(tape: i64, ptr: i64, pc: i64, c: i64, prog: String) -> (i64, i64) = {
    let ts = tape_size();

    if c == 62 {            -- '>' = 62
        (do_right(ptr, ts), pc)
    }
    else { if c == 60 {     -- '<' = 60
        (do_left(ptr, ts), pc)
    }
    else { if c == 43 {     -- '+' = 43
        let val = tape_get(tape, ptr);
        let _s = tape_set(tape, ptr, do_inc(val));
        (ptr, pc)
    }
    else { if c == 45 {     -- '-' = 45
        let val = tape_get(tape, ptr);
        let _s = tape_set(tape, ptr, do_dec(val));
        (ptr, pc)
    }
    else { if c == 46 {     -- '.' = 46 (output)
        let val = tape_get(tape, ptr);
        let _p = print_str(chr(val));
        (ptr, pc)
    }
    else { if c == 44 {     -- ',' = 44 (input - no-op)
        (ptr, pc)
    }
    else { if c == 91 {     -- '[' = 91
        let val = tape_get(tape, ptr);
        let new_pc = if val == 0 { find_matching_close(prog, pc) } else { pc };
        (ptr, new_pc)
    }
    else { if c == 93 {     -- ']' = 93
        let val = tape_get(tape, ptr);
        let new_pc = if val != 0 { find_matching_open(prog, pc) } else { pc };
        (ptr, new_pc)
    }
    else { (ptr, pc) } } } } } } } }
};

// Main interpreter
fn interpret(prog: String) -> i64 = {
    let tape = tape_new();
    let prog_len = prog.len();
    let mut ptr: i64 = 0;
    let mut pc: i64 = 0;
    let mut c: i64 = 0;
    let mut result: (i64, i64) = (0, 0);

    while pc < prog_len { {
        c = get_char(prog, pc);
        result = exec_instr(tape, ptr, pc, c, prog);
        ptr = result.0;
        pc = result.1 + 1;
        ()
    } };

    tape_free(tape)
};

// Test programs
fn hello_world() -> String =
    "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]" +
    ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.";

fn nested_loops() -> String =
    "++++++++++[>++++++++++[>++++++++++[>+<-]<-]<-]" +
    ">>>[-]++++++++[>+++++++++++<-]>.[-]++++++++++.";

fn add_test() -> String =
    "++++++++[>++++++++<-]>.";

// Run all test programs once (for output display)
fn run_tests_once() -> i64 = {
    let _u2 = print_str("Hello World: ");
    let _u3 = interpret(hello_world());
    let _u4 = printline("");

    let _u5 = print_str("Nested loops (1000 iterations): ");
    let _u6 = interpret(nested_loops());
    let _u7 = printline("");

    let _u8 = print_str("Add test (8*8=@): ");
    let _u9 = interpret(add_test());
    let _u10 = printline("");
    0
};

// Run benchmark loop (no output) - v0.55: 10x for ~50ms execution
fn run_benchmark_loop(n: i64) -> i64 =
    if n <= 0 { 0 }
    else {
        let _h = interpret(hello_world());
        let _n = interpret(nested_loops());
        let _a = interpret(add_test());
        run_benchmark_loop(n - 1)
    };

fn main() -> i64 = {
    let _u1 = printline("Brainfuck Interpreter Benchmark");

    -- Show output once
    let _t = run_tests_once();

    -- Run benchmark 10x for measurable timing (~50ms)
    let _b = run_benchmark_loop(9);

    let _u11 = printline("Done.");
    0
};

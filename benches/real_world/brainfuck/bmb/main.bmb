// brainfuck - Esoteric language interpreter benchmark
// Tests interpreter overhead, loop handling, array access
// v0.58: Nested if-else + tail recursion (short-circuit + TCO)
// v0.57: Inlined all instruction handlers to avoid tuple returns
// v0.55: Fixed to use 1-byte cells (like C) instead of 8-byte cells
// Performance target: C parity

fn printline(s: String) -> i64 = { let _u = println_str(s); 0 };

// Tape size (same as C version)
@const fn tape_size() -> i64 = 30000;

// Array operations using malloc for direct memory access (1 byte per cell, like C)
// v0.60.123: add @inline to all hot path functions
@inline fn tape_new() -> i64 = calloc(tape_size(), 1);  -- zero-initialized u8 array
@inline fn tape_free(tape: i64) -> i64 = { free(tape); 0 };
@inline fn tape_get(tape: i64, ptr: i64) -> i64 = load_u8(tape + ptr);
@inline fn tape_set(tape: i64, ptr: i64, val: i64) -> i64 = { store_u8(tape + ptr, val); 0 };

// Get byte at position in program string
@inline
fn get_char(prog: String, pos: i64) -> i64 =
    if pos >= prog.len() { 0 }
    else { prog.byte_at(pos) };

// Find matching bracket using while loop
fn find_matching_close(prog: String, start_pc: i64) -> i64 = {
    let mut pc: i64 = start_pc + 1;
    let mut depth: i64 = 1;
    let mut c: i64 = 0;

    while depth > 0 { {
        c = get_char(prog, pc);
        depth = if c == 91 { depth + 1 } else { if c == 93 { depth - 1 } else { depth } };
        pc = pc + 1;
        ()
    } };
    pc - 1
};

fn find_matching_open(prog: String, start_pc: i64) -> i64 = {
    let mut pc: i64 = start_pc - 1;
    let mut depth: i64 = 1;
    let mut c: i64 = 0;

    while depth > 0 { {
        c = get_char(prog, pc);
        depth = if c == 93 { depth + 1 } else { if c == 91 { depth - 1 } else { depth } };
        pc = pc - 1;
        ()
    } };
    pc + 1
};

// v0.58: Nested if-else for short-circuit evaluation (avoid checking all conditions)
// v0.57: Inlined instruction handlers

// Execute one instruction - returns (new_ptr, new_pc)
// v0.59: @inline forces LLVM alwaysinline attribute for aggressive inlining
@inline
fn exec_one(tape: i64, ptr: i64, pc: i64, c: i64, prog: String, ts: i64) -> (i64, i64) =
    if c == 62 {        -- '>'
        (if ptr + 1 >= ts { 0 } else { ptr + 1 }, pc)
    } else if c == 60 { -- '<'
        (if ptr == 0 { ts - 1 } else { ptr - 1 }, pc)
    } else if c == 43 { -- '+'
        let v = tape_get(tape, ptr);
        let _s = tape_set(tape, ptr, (v + 1) % 256);
        (ptr, pc)
    } else if c == 45 { -- '-'
        let v = tape_get(tape, ptr);
        let _s = tape_set(tape, ptr, if v == 0 { 255 } else { v - 1 });
        (ptr, pc)
    } else if c == 46 { -- '.'
        let v = tape_get(tape, ptr);
        let _p = print_str(chr(v));
        (ptr, pc)
    } else if c == 91 { -- '['
        let v = tape_get(tape, ptr);
        (ptr, if v == 0 { find_matching_close(prog, pc) } else { pc })
    } else if c == 93 { -- ']'
        let v = tape_get(tape, ptr);
        (ptr, if v != 0 { find_matching_open(prog, pc) } else { pc })
    } else {
        (ptr, pc)
    };

// Main interpreter loop using tail recursion
fn interpret_loop(tape: i64, prog: String, prog_len: i64, ts: i64, ptr: i64, pc: i64) -> i64 =
    if pc >= prog_len { 0 }
    else {
        let c = get_char(prog, pc);
        let result = exec_one(tape, ptr, pc, c, prog, ts);
        interpret_loop(tape, prog, prog_len, ts, result.0, result.1 + 1)
    };

fn interpret(prog: String) -> i64 = {
    let tape = tape_new();
    let prog_len = prog.len();
    let ts = tape_size();
    let _r = interpret_loop(tape, prog, prog_len, ts, 0, 0);
    tape_free(tape)
};

// Test programs
fn hello_world() -> String =
    "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]" +
    ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.";

fn nested_loops() -> String =
    "++++++++++[>++++++++++[>++++++++++[>+<-]<-]<-]" +
    ">>>[-]++++++++[>+++++++++++<-]>.[-]++++++++++.";

fn add_test() -> String =
    "++++++++[>++++++++<-]>.";

// Run all test programs once (for output display)
fn run_tests_once() -> i64 = {
    let _u2 = print_str("Hello World: ");
    let _u3 = interpret(hello_world());
    let _u4 = printline("");

    let _u5 = print_str("Nested loops (1000 iterations): ");
    let _u6 = interpret(nested_loops());
    let _u7 = printline("");

    let _u8 = print_str("Add test (8*8=@): ");
    let _u9 = interpret(add_test());
    let _u10 = printline("");
    0
};

// Run benchmark loop (no output) - v0.55: 10x for ~50ms execution
fn run_benchmark_loop(n: i64) -> i64 =
    if n <= 0 { 0 }
    else {
        let _h = interpret(hello_world());
        let _n = interpret(nested_loops());
        let _a = interpret(add_test());
        run_benchmark_loop(n - 1)
    };

fn main() -> i64 = {
    let _u1 = printline("Brainfuck Interpreter Benchmark");

    -- Show output once
    let _t = run_tests_once();

    -- Run benchmark 10x for measurable timing (~50ms)
    let _b = run_benchmark_loop(9);

    let _u11 = printline("Done.");
    0
};

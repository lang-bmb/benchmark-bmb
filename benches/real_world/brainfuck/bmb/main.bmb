// brainfuck - Esoteric language interpreter benchmark
// Tests interpreter overhead, loop handling, array access
// v0.57: Inlined all instruction handlers to avoid tuple returns
// v0.55: Fixed to use 1-byte cells (like C) instead of 8-byte cells
// Performance target: C parity

fn printline(s: String) -> i64 = { let _u = println_str(s); 0 };

// Tape size (same as C version)
fn tape_size() -> i64 = 30000;

// Array operations using malloc for direct memory access (1 byte per cell, like C)
fn tape_new() -> i64 = calloc(tape_size(), 1);  -- zero-initialized u8 array
fn tape_free(tape: i64) -> i64 = { free(tape); 0 };
fn tape_get(tape: i64, ptr: i64) -> i64 = load_u8(tape + ptr);
fn tape_set(tape: i64, ptr: i64, val: i64) -> i64 = { store_u8(tape + ptr, val); 0 };

// Get byte at position in program string
fn get_char(prog: String, pos: i64) -> i64 =
    if pos >= prog.len() { 0 }
    else { prog.byte_at(pos) };

// Find matching bracket using while loop
fn find_matching_close(prog: String, start_pc: i64) -> i64 = {
    let mut pc: i64 = start_pc + 1;
    let mut depth: i64 = 1;
    let mut c: i64 = 0;

    while depth > 0 { {
        c = get_char(prog, pc);
        depth = if c == 91 { depth + 1 } else { if c == 93 { depth - 1 } else { depth } };
        pc = pc + 1;
        ()
    } };
    pc - 1
};

fn find_matching_open(prog: String, start_pc: i64) -> i64 = {
    let mut pc: i64 = start_pc - 1;
    let mut depth: i64 = 1;
    let mut c: i64 = 0;

    while depth > 0 { {
        c = get_char(prog, pc);
        depth = if c == 93 { depth + 1 } else { if c == 91 { depth - 1 } else { depth } };
        pc = pc - 1;
        ()
    } };
    pc + 1
};

// v0.57: Inline all instruction handling in main loop to avoid tuple returns
// The C version uses a switch statement inline - we mirror this pattern

// Main interpreter - v0.57: All instructions inlined, no tuple returns
fn interpret(prog: String) -> i64 = {
    let tape = tape_new();
    let prog_len = prog.len();
    let ts = tape_size();
    let mut ptr: i64 = 0;
    let mut pc: i64 = 0;
    let mut c: i64 = 0;
    let mut val: i64 = 0;

    while pc < prog_len { {
        c = get_char(prog, pc);

        -- '>' = 62: move pointer right
        ptr = if c == 62 { if ptr + 1 >= ts { 0 } else { ptr + 1 } } else { ptr };

        -- '<' = 60: move pointer left
        ptr = if c == 60 { if ptr == 0 { ts - 1 } else { ptr - 1 } } else { ptr };

        -- '+' = 43: increment cell
        val = if c == 43 {
            let v = tape_get(tape, ptr);
            let _s = tape_set(tape, ptr, (v + 1) % 256);
            0
        } else { 0 };

        -- '-' = 45: decrement cell
        val = if c == 45 {
            let v = tape_get(tape, ptr);
            let _s = tape_set(tape, ptr, if v == 0 { 255 } else { v - 1 });
            0
        } else { 0 };

        -- '.' = 46: output
        val = if c == 46 {
            let v = tape_get(tape, ptr);
            let _p = print_str(chr(v));
            0
        } else { 0 };

        -- '[' = 91: jump forward if zero
        pc = if c == 91 {
            let v = tape_get(tape, ptr);
            if v == 0 { find_matching_close(prog, pc) } else { pc }
        } else { pc };

        -- ']' = 93: jump back if non-zero
        pc = if c == 93 {
            let v = tape_get(tape, ptr);
            if v != 0 { find_matching_open(prog, pc) } else { pc }
        } else { pc };

        { pc = pc + 1 };
        ()
    } };

    tape_free(tape)
};

// Test programs
fn hello_world() -> String =
    "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]" +
    ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.";

fn nested_loops() -> String =
    "++++++++++[>++++++++++[>++++++++++[>+<-]<-]<-]" +
    ">>>[-]++++++++[>+++++++++++<-]>.[-]++++++++++.";

fn add_test() -> String =
    "++++++++[>++++++++<-]>.";

// Run all test programs once (for output display)
fn run_tests_once() -> i64 = {
    let _u2 = print_str("Hello World: ");
    let _u3 = interpret(hello_world());
    let _u4 = printline("");

    let _u5 = print_str("Nested loops (1000 iterations): ");
    let _u6 = interpret(nested_loops());
    let _u7 = printline("");

    let _u8 = print_str("Add test (8*8=@): ");
    let _u9 = interpret(add_test());
    let _u10 = printline("");
    0
};

// Run benchmark loop (no output) - v0.55: 10x for ~50ms execution
fn run_benchmark_loop(n: i64) -> i64 =
    if n <= 0 { 0 }
    else {
        let _h = interpret(hello_world());
        let _n = interpret(nested_loops());
        let _a = interpret(add_test());
        run_benchmark_loop(n - 1)
    };

fn main() -> i64 = {
    let _u1 = printline("Brainfuck Interpreter Benchmark");

    -- Show output once
    let _t = run_tests_once();

    -- Run benchmark 10x for measurable timing (~50ms)
    let _b = run_benchmark_loop(9);

    let _u11 = printline("Done.");
    0
};

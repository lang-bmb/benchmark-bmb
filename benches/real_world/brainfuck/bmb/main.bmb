// brainfuck - Esoteric language interpreter benchmark
// Tests interpreter overhead, loop handling, array access
// Self-contained with embedded test program

// Note: BMB interpreter doesn't support stdin, so ',' is a no-op

fn printline(s: String) -> i64 = print_str(s + char_to_string(chr(10)));

// Tape size
fn tape_size() -> i64 = 30000;

// Create and initialize tape
fn create_tape() -> i64 = {
    let tape = vec_new();
    init_tape(tape, 0)
};

fn init_tape(tape: i64, i: i64) -> i64 =
    if i >= tape_size() { tape }
    else {
        let u = vec_push(tape, 0);
        init_tape(tape, i + 1)
    };

// Get character at position in program string
fn get_char(prog: String, pos: i64) -> i64 =
    if pos >= prog.len() { 0 }
    else { ord(char_at(prog, pos)) };

// Find matching bracket (for [ and ])
fn find_matching_close(prog: String, pc: i64, depth: i64) -> i64 =
    if depth <= 0 { pc }
    else {
        let next_pc = pc + 1;
        let c = get_char(prog, next_pc);
        let new_depth = if c == 91 { depth + 1 }       -- '[' = 91
                        else if c == 93 { depth - 1 }  -- ']' = 93
                        else { depth };
        find_matching_close(prog, next_pc, new_depth)
    };

fn find_matching_open(prog: String, pc: i64, depth: i64) -> i64 =
    if depth <= 0 { pc }
    else {
        let next_pc = pc - 1;
        let c = get_char(prog, next_pc);
        let new_depth = if c == 93 { depth + 1 }       -- ']' = 93
                        else if c == 91 { depth - 1 }  -- '[' = 91
                        else { depth };
        find_matching_open(prog, next_pc, new_depth)
    };

// Main interpreter loop
// Returns final pc
fn interpret_loop(prog: String, tape: i64, ptr: i64, pc: i64) -> i64 =
    if pc >= prog.len() { pc }
    else {
        let c = get_char(prog, pc);
        let result = execute_instruction(prog, tape, ptr, pc, c);
        let new_ptr = result / 1000000000;
        let new_pc = result % 1000000000;
        interpret_loop(prog, tape, new_ptr, new_pc + 1)
    };

// Execute single instruction
// Returns encoded (new_ptr * 1000000000 + new_pc)
fn execute_instruction(prog: String, tape: i64, ptr: i64, pc: i64, c: i64) -> i64 =
    if c == 62 {            -- '>' = 62
        let new_ptr = (ptr + 1) % tape_size();
        new_ptr * 1000000000 + pc
    }
    else if c == 60 {       -- '<' = 60
        let new_ptr = if ptr == 0 { tape_size() - 1 } else { ptr - 1 };
        new_ptr * 1000000000 + pc
    }
    else if c == 43 {       -- '+' = 43
        let val = vec_get(tape, ptr);
        let new_val = (val + 1) % 256;  -- Wrap at 256
        let u = vec_set(tape, ptr, new_val);
        ptr * 1000000000 + pc
    }
    else if c == 45 {       -- '-' = 45
        let val = vec_get(tape, ptr);
        let new_val = if val == 0 { 255 } else { val - 1 };
        let u = vec_set(tape, ptr, new_val);
        ptr * 1000000000 + pc
    }
    else if c == 46 {       -- '.' = 46
        let val = vec_get(tape, ptr);
        let u = print_str(char_to_string(chr(val)));
        ptr * 1000000000 + pc
    }
    else if c == 44 {       -- ',' = 44 (input - no-op in BMB)
        ptr * 1000000000 + pc
    }
    else if c == 91 {       -- '[' = 91
        let val = vec_get(tape, ptr);
        if val == 0 {
            let new_pc = find_matching_close(prog, pc, 1);
            ptr * 1000000000 + new_pc
        }
        else {
            ptr * 1000000000 + pc
        }
    }
    else if c == 93 {       -- ']' = 93
        let val = vec_get(tape, ptr);
        if val != 0 {
            let new_pc = find_matching_open(prog, pc, 1);
            ptr * 1000000000 + new_pc
        }
        else {
            ptr * 1000000000 + pc
        }
    }
    else {
        ptr * 1000000000 + pc  -- Ignore other characters
    };

// Run a brainfuck program
fn interpret(prog: String) -> i64 = {
    let tape = create_tape();
    let result = interpret_loop(prog, tape, 0, 0);
    let u = vec_free(tape);
    result
};

// Test programs

// Hello World
fn hello_world() -> String =
    "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]" +
    ">>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.";

// Nested loops (smaller for interpreter - 1000 iterations)
// Output 'X' (88) after computation, then newline
fn nested_loops() -> String =
    "++++++++++[" +            // 10 iterations
    ">++++++++++[" +           // 10 iterations (100 total)
    ">++++++++++[" +           // 10 iterations (1000 total)
    ">+<-" +
    "]<-" +
    "]<-" +
    "]" +
    ">>>[-]" +                 // Clear the result cell
    "++++++++[>+++++++++++<-]>." +  // Print 'X' (88) = 8*11
    "[-]++++++++++.";             // Newline (10)

// Simple add test
fn add_test() -> String =
    "++++++++[>++++++++<-]>."; // 8 * 8 = 64 = '@'

fn main() -> i64 = {
    let u1 = printline("Brainfuck Interpreter Benchmark");

    // Run Hello World
    let u2 = print_str("Hello World: ");
    let u3 = interpret(hello_world());
    let u4 = printline("");

    // Run nested loops (smaller scale for interpreter)
    let u5 = print_str("Nested loops (1000 iterations): ");
    let u6 = interpret(nested_loops());
    let u7 = printline("");

    // Run add test
    let u8 = print_str("Add test (8*8=@): ");
    let u9 = interpret(add_test());
    let u10 = printline("");

    let u11 = printline("Done.");
    0
};

// Surpass Benchmark: Graph Traversal
// Goal: BMB > C through reachability proof removes visit checks
//
// Strategy: Contract proves all nodes are reachable from start,
// allowing skip of visited-set maintenance
//
// BMB advantage: Graph property verification at compile-time

// Graph represented as adjacency list in flat arrays
// 8 nodes, max 4 edges per node
// edges[node * 4 + i] = neighbor or -1 if no edge

// Check if graph is connected (all nodes reachable from 0)
// Simplified: check that each node has at least one incoming edge
@pure
fn has_incoming(edges: [i64; 32], node: i64, check_from: i64) -> i64
  pre node >= 0 and node < 8 and check_from >= 0
= if check_from >= 8 { 0 }  // No incoming edge found
  else {
    let base = check_from * 4;
    if edges[base] == node { 1 }
    else if edges[base + 1] == node { 1 }
    else if edges[base + 2] == node { 1 }
    else if edges[base + 3] == node { 1 }
    else { has_incoming(edges, node, check_from + 1) }
  };

// Check connectivity (simplified: all non-zero nodes have incoming)
@pure
fn is_connected(edges: [i64; 32], node: i64) -> i64
  pre node >= 0
= if node >= 8 { 1 }  // All nodes checked
  else if node == 0 { is_connected(edges, node + 1) }  // Node 0 is start
  else if has_incoming(edges, node, 0) == 0 { 0 }  // Not connected
  else { is_connected(edges, node + 1) };

// Sum node values during traversal (with connectivity guarantee)
@pure
fn traverse_with_proof(edges: [i64; 32], values: [i64; 8], node: i64, depth: i64, acc: i64) -> i64
  pre node >= 0 and depth >= 0 and is_connected(edges, 0) == 1
= if depth > 16 { acc }  // Depth limit to prevent infinite recursion
  else if node >= 8 { acc }
  else if node < 0 { acc }
  else {
    let new_acc = acc + values[node];
    let base = node * 4;
    // Visit neighbors (no need for visited set due to depth limit)
    let n0 = edges[base];
    let n1 = edges[base + 1];
    let n2 = edges[base + 2];
    let n3 = edges[base + 3];
    let a0 = if n0 >= 0 { traverse_with_proof(edges, values, n0, depth + 1, 0) } else { 0 };
    let a1 = if n1 >= 0 { traverse_with_proof(edges, values, n1, depth + 1, 0) } else { 0 };
    let a2 = if n2 >= 0 { traverse_with_proof(edges, values, n2, depth + 1, 0) } else { 0 };
    let a3 = if n3 >= 0 { traverse_with_proof(edges, values, n3, depth + 1, 0) } else { 0 };
    new_acc + a0 + a1 + a2 + a3
  };

// Traverse without proof (must maintain visited set simulation)
fn traverse_without_proof(edges: [i64; 32], values: [i64; 8], visited: [i64; 8], node: i64, depth: i64, acc: i64) -> i64 =
  if depth > 16 { acc }
  else if node < 0 { acc }
  else if node >= 8 { acc }
  else if visited[node] != 0 { acc }  // Already visited (runtime check)
  else {
    let new_acc = acc + values[node];
    // Mark visited (would need mutation, simulate with depth)
    let base = node * 4;
    let n0 = edges[base];
    let n1 = edges[base + 1];
    let n2 = edges[base + 2];
    let n3 = edges[base + 3];
    // Simplified: just traverse with depth limit
    let a0 = if n0 >= 0 { traverse_without_proof(edges, values, visited, n0, depth + 1, 0) } else { 0 };
    let a1 = if n1 >= 0 { traverse_without_proof(edges, values, visited, n1, depth + 1, 0) } else { 0 };
    let a2 = if n2 >= 0 { traverse_without_proof(edges, values, visited, n2, depth + 1, 0) } else { 0 };
    let a3 = if n3 >= 0 { traverse_without_proof(edges, values, visited, n3, depth + 1, 0) } else { 0 };
    new_acc + a0 + a1 + a2 + a3
  };

// Run iterations with connectivity proof
fn run_with_proof(edges: [i64; 32], values: [i64; 8], remaining: i64, acc: i64) -> i64 =
  if remaining <= 0 { acc }
  else { run_with_proof(edges, values, remaining - 1, acc + traverse_with_proof(edges, values, 0, 0, 0)) };

// Run iterations without proof
fn run_without_proof(edges: [i64; 32], values: [i64; 8], visited: [i64; 8], remaining: i64, acc: i64) -> i64 =
  if remaining <= 0 { acc }
  else { run_without_proof(edges, values, visited, remaining - 1, acc + traverse_without_proof(edges, values, visited, 0, 0, 0)) };

// Main
fn main() -> i64 = {
    // Connected graph edges (adjacency list)
    // Node 0: edges to 1, 2
    // Node 1: edges to 3, 4
    // Node 2: edges to 5, 6
    // Node 3: edge to 7
    // Node 4: edge to 7
    // Node 5: edge to 7
    // Node 6: edge to 7
    // Node 7: no outgoing (leaf)
    let edges: [i64; 32] = [
        1, 2, -1, -1,   // Node 0
        3, 4, -1, -1,   // Node 1
        5, 6, -1, -1,   // Node 2
        7, -1, -1, -1,  // Node 3
        7, -1, -1, -1,  // Node 4
        7, -1, -1, -1,  // Node 5
        7, -1, -1, -1,  // Node 6
        -1, -1, -1, -1  // Node 7
    ];
    let values: [i64; 8] = [10, 20, 30, 40, 50, 60, 70, 80];
    let visited: [i64; 8] = [0, 0, 0, 0, 0, 0, 0, 0];

    let with_proof = run_with_proof(edges, values, 2000, 0);
    let without_proof = run_without_proof(edges, values, visited, 2000, 0);
    let result = with_proof + without_proof;
    let _u = println(result);
    0
};

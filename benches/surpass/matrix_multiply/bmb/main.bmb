// Surpass Benchmark: Matrix Multiply
// Goal: BMB > C through contract-based aliasing guarantees
//
// Strategy: Contracts prove no aliasing between matrices,
// enabling aggressive SIMD optimization that C restrict cannot match
//
// BMB advantage: Pure functions + contracts = guaranteed no aliasing

// Matrix represented as flat array (row-major)
// 8x8 matrix = 64 elements

// Pure matrix element access with bounds proof
@pure
fn mat_get(mat: [i64; 64], row: i64, col: i64) -> i64
  pre row >= 0 and row < 8 and col >= 0 and col < 8
= mat[row * 8 + col];

// Compute single cell of result matrix
// Dot product of row from A and column from B
@pure
fn compute_cell(a: [i64; 64], b: [i64; 64], row: i64, col: i64, k: i64, acc: i64) -> i64
  pre row >= 0 and row < 8 and col >= 0 and col < 8 and k >= 0
= if k >= 8 { acc } else {
    let a_val = mat_get(a, row, k);
    let b_val = mat_get(b, k, col);
    compute_cell(a, b, row, col, k + 1, acc + a_val * b_val)
  };

// Compute row of result matrix
fn compute_row(a: [i64; 64], b: [i64; 64], row: i64, col: i64, acc: i64) -> i64
  pre row >= 0 and row < 8 and col >= 0
= if col >= 8 { acc } else {
    let cell = compute_cell(a, b, row, col, 0, 0);
    compute_row(a, b, row, col + 1, acc + cell)
  };

// Sum entire result matrix (simplified: sum all cells)
fn matrix_multiply_sum(a: [i64; 64], b: [i64; 64], row: i64, acc: i64) -> i64
  pre row >= 0
= if row >= 8 { acc } else {
    let row_sum = compute_row(a, b, row, 0, 0);
    matrix_multiply_sum(a, b, row + 1, acc + row_sum)
  };

// Run iterations
fn run_iterations(a: [i64; 64], b: [i64; 64], remaining: i64, acc: i64) -> i64 =
  if remaining <= 0 { acc } else {
    run_iterations(a, b, remaining - 1, acc + matrix_multiply_sum(a, b, 0, 0))
  };

// Main
fn main() -> i64 = {
    let a: [i64; 64] = [
        1, 2, 3, 4, 5, 6, 7, 8,
        2, 3, 4, 5, 6, 7, 8, 9,
        3, 4, 5, 6, 7, 8, 9, 10,
        4, 5, 6, 7, 8, 9, 10, 11,
        5, 6, 7, 8, 9, 10, 11, 12,
        6, 7, 8, 9, 10, 11, 12, 13,
        7, 8, 9, 10, 11, 12, 13, 14,
        8, 9, 10, 11, 12, 13, 14, 15
    ];
    let b: [i64; 64] = [
        1, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 0, 0,
        0, 0, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 1, 0, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 1, 0,
        0, 0, 0, 0, 0, 0, 0, 1
    ];
    run_iterations(a, b, 1000, 0)
};
